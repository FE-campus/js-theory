# 1주차

## 변수와 상수

**let, var, const**

- 기본적으로 const, 안되면 let
- a = 1 은 전역 선언
- var 함수 스코프
- let 지역 변수

자바스크립트에선 let 키워드를 사용해 변수를 생성합니다.

1. 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있습니다.
2. 첫 글자는 숫자가 될 수 없습니다.

변화하지 않는 변수를 선언할 땐, let 대신 const를 사용합니다.

pageLoadTime의 값은 페이지가 로드되기 전에는 정해지지 않기 때문에 일반적인 방식으로 변수명을 지었습니다. 하지만 이 값은 최초 할당 이후에 변경되지 않으므로 여전히 상수입니다.

정리하자면, 대문자 상수는 “하드 코딩한” 값의 별칭을 만들 때 사용하면 됩니다.

이처럼 자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있는 언어를 ‘동적 타입(dynamically typed)’ 언어라고 부릅니다.

## 자료형

**숫자형**

- NaN은 계산 중에 에러가 발생했다는 것을 나타내주는 값입니다. 부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중에 에러가 발생하는 데, 이때 NaN이 반환됩니다. (isNaN)
- `BigInt` BigInt는 정수 리터럴 끝에 n을 붙이면 만들 수 있습니다. `const bigInt = 1234567890123456789012345678901234567890n;`

**문자형**

- 큰따옴표("")와 작은따옴표('')는 ‘기본적인’ 따옴표로, 자바스크립트에서는 이 둘에 차이를 두지 않습니다.
- 역 따옴표(``)로 변수나 표현식을 감싼 후 ${…}안에 넣어주면, 아래와 같이 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 있습니다. `alert( `the result is ${1 + 2}` ); // the result is 3`
- 자바스크립트는 글자형을 지원하지 않습니다. 문자형만 있을 뿐입니다. 여기엔 글자가 하나 혹은 여러 개 들어갈 수 있습니다. (char 지원 안함)

**불린형**

**undefined, null**

- undefined: 선언은 됐지만 할당은 안된 경우
- null : 자료가 있다가 없어진 경우 등 다양함

**'null' 값**

- 자바스크립트에선 `null`을 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용합니다.
- `let age = null;`은 `나이(age)`를 알 수 없거나 그 값이 비어있음을 보여줍니다.

**'undefined' 값**

- `undefined` 값도 `null` 값처럼 자신만의 자료형을 형성합니다.
- `undefined`는 '값이 할당되지 않은 상태’를 나타낼 때 사용합니다.
- 변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined`가 자동으로 할당됩니다.
- `undefined`는 변수에 값이 할당되었는지 여부를 확인할 때 사용하도록 합시다.
- `null`과 `undefined`은 숫자형으로 변환 시 결과가 다르다는 점에 유의하시기 바랍니다. `null`은 0이 되고 `undefined`는 `NaN`이 됩니다.

**객체와 심볼**

- `객체(object)`형은 특수한 자료형입니다.
- 객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부릅니다. 반면 객체는 데이터 컬렉션이나 복잡한 개체(entity)를 표현할 때 사용합니다.
- 심볼(symbol)형은 객체의 고유한 식별자(unique identifier)를 만들 때 사용됩니다.

## Alert, Prompt, Confirm

```
alert("hello");
result = prompt(title, [default]);
```

- 이 함수는 텍스트 메시지와 입력 필드(input field), 확인(OK) 및 취소(Cancel) 버튼이 있는 모달 창을 띄워줍니다.
- **`title`**사용자에게 보여줄 문자열. **`default`**입력 필드의 초기값(선택사항).
- 사용자는 프롬프트 대화상자의 입력 필드에 원하는 값을 입력하고 확인을 누를 수 있습니다. 값을 입력하길 원하지 않는 경우는 취소(Cancel) 버튼을 누르거나 Esc를 눌러 대화상자를 빠져나갈 수 있습니다.
- `prompt` 함수는 사용자가 입력 필드에 기재한 문자열을 반환합니다. 사용자가 입력을 취소한 경우는 `null`이 반환됩니다.

```jsx
let age = prompt('나이를 입력해주세요.', 100);

alert(`당신의 나이는 ${age}살 입니다.`); // 당신의 나이는 100살입니다.
result = confirm(question);
let isBoss = confirm("당신이 주인인가요?");

alert( isBoss ); // 확인 버튼을 눌렀다면 true가 출력됩니다.
let age = prompt('나이를 입력해주세요.', 18);

let message = (age < 3) ? '아기야 안녕?' :
  (age < 18) ? '안녕!' :
  (age < 100) ? '환영합니다!' :
  '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';

alert( message );
```

NOT을 두 개 연달아 사용(!!)하면 값을 불린형으로 변환할 수 있습니다.

참고로, 내장 함수 Boolean을 사용하면 !!을 사용한 것과 같은 결과를 도출할 수 있습니다.

## 함수

*함수 선언(function declaration)* 방식을 이용하면 함수를 만들 수 있습니다

함수 선언 방식은 아래와 같이 작성할 수 있습니다.

```jsx
function name(parameters) {
  ...함수 본문...
}

function showMessage(from, text = "no text given") { // 기본값(default value) 설정
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given

function showMessage(from, text = anotherFunction()) {
  // anotherFunction()은 text값이 없을 때만 호출됨
  // anotherFunction()의 반환 값이 text의 값이 됨
}
```

`return`문이 없는 함수도 무언가를 반환합니다. `undefined`를 반환하죠.

`return` 지시자만 있는 경우도 `undefined`를 반환합니다. `return`은 `return undefined`와 동일하게 동작하죠.

```jsx
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "동의하셨습니다." );
}

function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
ask("동의하십니까?", showOk, showCancel);

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);
```

함수 `ask`의 인수, `showOk`와 `showCancel`은 콜백 함수 또는 콜백이라고 불립니다.

**함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성합니다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있습니다.**

위 예시를 이용해 설명해 보도록 하겠습니다. 스크립트가 실행되고, 실행 흐름이 `let sum = function…`의 우측(함수 표현식)에 도달 했을때 함수가 생성됩니다. 이때 이후부터 해당 함수를 사용(할당, 호출 등)할 수 있습니다.

하지만 함수 선언문은 조금 다릅니다.

**함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수 있습니다.**

따라서 전역 함수 선언문은 스크립트 어디에 있느냐에 상관없이 어디에서든 사용할 수 있습니다.

이게 가능한 이유는 자바스크립트의 내부 알고리즘 때문입니다. 자바스크립트는 스크립트를 실행하기 전, 준비단계에서 전역에 선언된 함수 선언문을 찾고, 해당 함수를 생성합니다. 스크립트가 진짜 실행되기 전 "초기화 단계"에서 함수 선언 방식으로 정의한 함수가 생성되는 것이죠.

스크립트는 함수 선언문이 모두 처리된 이후에서야 실행됩니다. 따라서 스크립트 어디서든 함수 선언문으로 선언한 함수에 접근할 수 있는 것입니다.

**엄격 모드에서 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있습니다. 하지만 블록 밖에서는 함수에 접근하지 못합니다.**

### **생성자 함수**

생성자 함수(constructor function)와 일반 함수에 기술적인 차이는 없습니다. 다만 생성자 함수는 아래 두 관례를 따릅니다.

1. 함수 이름의 첫 글자는 대문자로 시작합니다.
2. 반드시 `"new"` 연산자를 붙여 실행합니다.

```js
function User(name) {
  // this = {};  (빈 객체가 암시적으로 만들어짐)

  // 새로운 프로퍼티를 this에 추가함
  this.name = name;
  this.isAdmin = false;

  // return this;  (this가 암시적으로 반환됨)
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
```



`new User(...)`를 써서 함수를 실행하면 아래와 같은 알고리즘이 동작합니다.

1. 빈 객체를 만들어 `this`에 할당합니다.
2. 함수 본문을 실행합니다. `this`에 새로운 프로퍼티를 추가해 `this`를 수정합니다.
3. `this`를 반환합니다.

그런데 만약 `return` 문이 있다면 어떤 일이 벌어질까요? 아래와 같은 간단한 규칙이 적용됩니다.

- 객체를 `return` 한다면, `this` 대신 객체가 반환됩니다.
- 원시형을 `return` 한다면, `return`문이 무시됩니다.