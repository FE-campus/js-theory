# 1주차

## 4.1 객체

객체형 : 오직 한 가지의 데이터만 담을 수 있는 원시형(primitive type)과 달리 다양한 데이터를 담을 수 있음.

`객체 = { key : value, key2 : value2, ... }`

빈 객체 생성 (생성자/리터럴) : `let user = new Object();` or `let user = {}`

-   주의사항 : `const user = {name: 'John'}` 의 경우, const는 user의 값을 고정하지만 그 내용은 고정하지 않기 때문에 `user.name = 'Pete';` 로 수정이 가능함.

### 대괄호 표기법

객체의 키가 “ “ 로 묶여있는 경우에는 대괄호 표기법으로 해당 프로퍼티 값을 읽어올 수 있음. e.g.) `user["like birds"] = true;`

대괄호 표기법 활용 예

```jsx
let user = {
	name: "John",
	age: 30,
};

let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요?", "name");

alert(user[key]);
// name 을 입력한 경우 John 출력 가능
```

computed property : 객체 리터럴 안의 프로퍼티 키가 대괄호로 묶여있는 경우를 의미.

```jsx
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {
	[fruit]: 5,
	// 입력받은 값을 key에 할당
};

/////////

// 위의 코드와 동일하게 동작함
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
let bag = {};
bag[fruit] = 5;
```

### 단축 프로퍼티

: 변수를 사용해서 프로퍼티를 만들 때 프로퍼티의 키와 변수명이 동일한 경우 프로퍼티 값 단축 구문 (property value shorthand)을 사용할 수 있음.

한 객체에서 일반 프로퍼티와 단축 프로퍼티 함께 사용 가능

```jsx
let user = {
	name,
	age: 30,
};
```

### 객체 내 프로퍼티 존재 여부 확인

`"key" in user`

`in` 을 활용해서 객체 내 해당 프로퍼티의 존재 여부를 확인할 수 있다.

객체 내 해당 프로퍼티가 존재하지 않으면 에러 대신 `undefined`를 반환한다.

---

## 4.2 참조에 의한 객체 복사

객체는 원시 타입과 달리 참조에 의해 저장, 복사된다.

즉, 객체 값 자체가 그대로 저장되지 않고 객체가 저장된 메모리상의 주소인 참조 값이 저장된다.

객체를 비교할 때는 동등 연산자(==)와 일치 연산자(===) 는 동일하게 동작한다.

객체를 비교할 때 비교의 대상이 되는 두 객체가 동일할 경우 true를 반환한다.

대부분의 객체 복사는 참조를 이용한 복사로 해결 가능하다. 하지만 복제가 필요한 상황이라면 새 객체를 만들고 기존 객체의 프로퍼티들을 순회해서 새 객체에 프로퍼티들을 복사하는 방법을 사용할 수 있다.

또는 `Object.assign` 을 사용해서도 가능하다.

`Object.assign(dest, [src1, src2, ...])`

⇒ dest - 목표로 하는 객체 / src - 복사하고자 하는 객체

만약 객체의 모든 프로퍼티가 원시값이 아니라 중첩 객체일 경우에는 중첩 객체의 구조도 복사하는 반복문을 사용해야 하며 이와 같은 방식을 깊은 복사(deep cloning) 이라고 한다.

---

## 4.4 메서드와 this

메서드 (method) : 객체 프로퍼티에 할당된 함수.

메서드는 함수 표현식으로 직접 객체 프로퍼티에 할당 해 줄 수도 있고 이미 정의된 함수를 이용해서도 만들 수 있다.

메서드 단축 구문을 사용하면 function 을 생략해도 메서드를 정의 할 수 있다.

```jsx
user = {
	sayHi() {
		alert("Hello");
	},
};
```

(유의할 점: 일반적인 방법과 단축 구문을 사용한 방법은 완전히 동일하지는 않음. 객체 상속과 관련해서 차이가 존재함을 알아두기)

메서드 내부에서 `this` 키워드를 사용하여 객체에 접근 할 수 있다.

e.g.) `this.name`

JavaScript에서 `this` 는 모든 함수에서 사용가능하다. 예를 들어 동일한 함수라도 서로 다른 객체에서 호출한다면 `this` 가 참조하는 값이 다르다.

그러나 화살표 함수에서는 고유한 `this`를 가지지 않는다. 화살표 함수에서 `this` 를 참조할 경우 화살표 함수 외부의 일반 함수에서 `this` 값을 가져온다.

따라서 외부 컨텍스트에 있는 `this` 를 사용하고 싶은 경우에는 화살표 함수가 유용하다.

---

## 4.5 new 연산자와 생성자 함수

유사한 객체를 여러 개 만들어야 할 때 `new` 연산자와 생성자 함수를 사용하면 쉽게 만들 수 있다.

### 생성자 함수 (constructor function)

: 생성자 함수와 일반 함수에 기술적인 차이는 없지만 생성자 함수는 함수 이름의 첫 글자가 대문자로 시작하며, 반드시 `new` 연산자를 붙여 실행한다는 두 가지의 관례를 따른다. (+일반 함수와 구분하기 위해 함수 이름의 첫 글자를 대문자로 표기한다.)

생성자 함수를 사용하여 객체를 만들면 재사용할 수 있는 객체 생성 코드를 구현할 수 있다는 생성자의 의의를 실현할 수 있다.

`new` 연산자를 사용한 함수의 동작

1. 빈 객체를 생성해 `this` 에 할당
2. 함수 본문 실행 ⇒ `this` 에 새로운 프로퍼티 추가해서 `this` 수정
3. `this` 반환

함수 본문에서 `new.target` 프로퍼티를 사용하면 해당 함수가 `new` 와 함께 호출되었는지의 여부를 알 수 있다.

생성자 함수에는 일반적으로 `return` 문이 존재하지 않는데 만약 `return` 문이 존재하고 해당 `return` 문이 객체를 `return` 한다면 `this` 대신 객체가 반환되고 원시형을 `return` 한다면 `return` 문은 무시된다.

생성자 함수를 사용하면 `this` 에 프로퍼티 뿐 아리나 메서드 또한 더해줄 수 있다.

---

## 4.6 옵셔널 체이닝 (optional chaining)

옵셔널 체이닝 `?.` 은 `?.` 앞의 대상이 `undefined` 또는 `null` 일 경우 평가를 멈추고 `undefined` 를 반환한다. (단락 평가/short-circuit)

옵셔널 체이닝을 사용하면 프로퍼티가 없는 중첩 객체에 에러 없이 접근할 수 있음.

옵셔널 체이닝은 연산자가 아니라 특별한 문법 구조체이다.

옵셔널 체이닝은 그 값이 존재하지 않아도 되는 대상에만 사용해야 하며 옵셔널 체이닝 앞의 변수는 반드시 선언되어 있어야 한다. 또한 옵셔널 체이닝은 읽기, 삭제에만 사용할 수 있고 쓰기에는 사용할 수없다.

활용 예

```jsx
let user1 = {
	admin() {
		alert("관리자 계정입니다.");
	},
};

let user2 = {};

user1.admin?.(); // admin() => alert 동작
user2.admin?.();
```

```jsx
let user1 = {
	firstName: "Violet",
};

let user2 = null;

let key = "firstName";

alert(user1?.[key]); // user1의 fistName 값인 Violet 반환
alert(user2?.[key]); // undefined

alert(user1?.[key]?.something?.not?.existing); // undefined
```
