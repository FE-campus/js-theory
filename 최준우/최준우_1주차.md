# 모던 JavaScript 튜토리얼

# 2.1

## [‘script’ 태그](https://ko.javascript.info/hello-world#ref-1)

<script> 태그를 이용하면 자바스크립트 프로그램을 HTML 문서 대부분의 위치에 삽입할 수 있다.

```markdown
<!DOCTYPE HTML>
<html>

<body>

  <p>스크립트 전</p>

  <script>
    alert( 'Hello, world!' );
  </script>

  <p>스크립트 후</p>

</body>

</html>
```

<script> 태그엔 자바스크립트 코드가 들어간다. 브라우저는 이 태그를 만나면 안의 코드를 자동으로 처리한다.

## [모던 마크업](https://ko.javascript.info/hello-world#ref-2)

<script> 태그엔 몇 가지 속성(attribute)이 있다. 요즘엔 잘 사용하진 않지만, 오래된 코드에서 종종 이 속성을 발견할 수 있다.

- `type` 속성: `<script type=…>`

  HTML4에선 스크립트에 `type`을 명시하는 것이 필수였습니다. 따라서 `type="text/javascript"` 속성이 붙은 스크립트를 어렵지 않게 찾을 수 있었습니다. 이젠 타입 명시가 필수가 아닙니다. 게다가 모던 HTML 표준에선 이 속성의 의미가 바뀌었습니다. 이제 이 속성은 자바스크립트 모듈에 사용할 수 있습니다. 모듈은 심화 내용이기 때문에 다른 파트에서 다시 이야기하도록 하겠습니다.

- `language` 속성: `<script language=…>`

  이 속성은 현재 사용하고 있는 스크립트 언어를 나타냅니다. 지금은 자바스크립트가 기본 언어이므로 속성의 의미가 퇴색된 상황입니다. 더는 사용할 필요가 없어졌죠.

- 스크립트 전후에 위치한 주석

  아주 오래된 책과 가이드에서는 다음과 같이 `<script>` 태그 안에 주석이 존재하는 걸 볼 수 있습니다.`<script type="text/javascript"><!--    ... //--></script>`모던 자바스크립트에선 이런 트릭을 사용하지 않습니다. 태그 옆에 붙은 주석은 `<script>` 태그를 처리하지 못하는 브라우저가 해당 스크립트를 읽지 못하게 하려고 사용했었죠. 지난 15년간 출시된 브라우저는 `<script>` 태그를 처리할 수 있으므로, 이런 형태의 주석을 보면 아주 오래된 코드라는 사실을 알 수 있습니다.

## [외부 스크립트](https://ko.javascript.info/hello-world#ref-3)

자바스크립트 코드의 양이 많은 경우엔, 파일로 소분하여 저장할 수 있다.

이렇게 분해해 놓은 각 파일은 `src` 속성을 사용해 HTML에 삽입한다.

```markup
<script src="/path/to/script.js"></script>
```

여기서 `/path/to/script.js`는 사이트의 루트에서부터 파일이 위치한 절대 경로를 나타냅니다. 현재 페이지에서의 상대 경로를 사용하는 것도 가능합니다. 같은 폴더 내에 있는 파일인 `"script.js"`를 `src="script.js"`로 참조하는 것처럼 말이죠.

물론 아래와 같이 URL 전체를 속성으로 사용할 수도 있습니다.

```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
```

복수의 스크립트를 HTML에 삽입하고 싶다면 스크립트 태그를 여러 개 사용하면 됩니다.

```markup
<script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
```

**주의:**

HTML 안에 직접 스크립트를 작성하는 방식은 대개 스크립트가 아주 간단할 때만 사용합니다. 스크립트가 길어지면 별개의 분리된 파일로 만들어 저장하는 것이 좋습니다.

스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 [캐시(cache)](https://en.wikipedia.org/wiki/Web_cache)에 저장하기 때문에, 성능상의 이점이 있습니다.

여러 페이지에서 동일한 스크립트를 사용하는 경우, 브라우저는 페이지가 바뀔 때마다 스크립트를 새로 다운받지 않고 캐시로부터 스크립트를 가져와 사용합니다. 스크립트 파일을 한 번만 다운받으면 되죠.

이를 통해 트래픽이 절약되고 웹 페이지의 실제 속도가 빨라집니다.

**`src` 속성이 있으면 태그 내부의 코드는 무시됩니다.**

<script> 태그는 src 속성과 내부 코드를 동시에 가지지 못합니다.

다음 코드는 실행되지 않습니다.

```markup
<script src="file.js">
  alert(1); // src 속성이 사용되었으므로 이 코드는 무시됩니다.
</script>
```

따라서 `<script src="…">`로 외부 파일을 연결할지 아니면 `<script>` 태그 내에 코드를 작성할지를 선택해야 합니다.

위의 예시는 스크립트 두 개로 분리하면 정상적으로 실행됩니다.

```markup
<script src="file.js"></script>
<script>
  alert(1);
</script>
```

## [요약](https://ko.javascript.info/hello-world#ref-4)

- 웹 페이지에 자바스크립트 코드를 추가하기 위해 `<script>` 태그를 사용합니다.
- `type` 과 `language` 속성은 필수가 아닙니다.
- 외부 스크립트 파일은 `<script src="path/to/script.js"></script>`와 같이 삽입합니다.

# 2.2

# 코드 구조

처음으로 배울 것은 코드 블록을 만드는 방법입니다.

## [문](https://ko.javascript.info/structure#ref-1129)

문(statement)은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미합니다.

앞서 ‘Hello, world!’ 메시지를 보여주는 `alert('Hello, world!')` 문을 확인한 바 있습니다.

코드엔 원하는 만큼 문을 작성할 수 있습니다. 이때, 서로 다른 문은 세미콜론으로 구분합니다.

아래 코드는 'Hello World’를 두 개의 alert 문으로 나눈 예시입니다.

```javascript
alert('Hello'); alert('World');
```

코드의 가독성을 높이기 위해 각 문은 서로 다른 줄에 작성하는 것이 일반적입니다.

```javascript
alert('Hello');
alert('World');
```

## [세미콜론](https://ko.javascript.info/structure#semicolon)

줄 바꿈이 있다면 세미콜론(semicolon)을 생략할 수 있습니다.

아래 코드는 에러 없이 동작합니다.

```javascript
alert('Hello')
alert('World')
```

자바스크립트는 줄 바꿈이 있으면 이를 ‘암시적’ 세미콜론으로 해석합니다. 이런 동작 방식을 [세미콜론 자동 삽입(automatic semicolon insertion)](https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion)이라 부릅니다.

**대부분의 경우, 줄 바꿈은 세미콜론을 의미합니다. 하지만 '대부분의 경우’가 '항상’을 의미하진 않습니다.**

아래와 같이 줄 바꿈이 세미콜론을 의미하지 않는 경우도 있습니다.

```javascript
alert(3 +
1
+ 2);
```

세미콜론 자동 삽입이 일어나지 않았기 때문에 `6`이 출력됩니다. 어떤 줄이 `"+"` 로 끝나면, 그 줄은 '불완전한 표현식’이므로 세미콜론이 필요하지 않다는 걸 직감하실 겁니다. 위 코드도 이런 의도로 동작합니다.

**반면, 세미콜론이 정말로 필요하지만 자바스크립트가 이를 추정하지 ‘못하는’ 상황도 존재합니다.**

이런 상황에서 발생하는 에러는 찾거나 고치기가 상당히 어렵습니다.

**에러 예제**

자바스크립트가 세미콜론을 자동으로 삽입해주지 못하는 구체적인 상황은 다음과 같습니다.

```javascript
[1, 2].forEach(alert)
```

지금은 대괄호 `[]`와 `forEach`는 아직 배우지 않았으므로, 깊이 생각하지 말고 코드를 살펴봅시다. 이들에 대해선 추후에 학습할 예정입니다. 코드를 실행하면 결과가 `1`과 `2`가 출력된다는 사실만 기억하세요.

이제 위에서 작성한 코드 앞쪽에 *세미콜론을 붙이지 않은 채* `alert`를 추가해 봅시다.

```javascript
alert("에러가 발생합니다.")

[1, 2].forEach(alert)
```

예제를 실행해 보면 새롭게 추가한 `alert`만 제대로 출력되고 에러가 발생하는 걸 확인할 수 있습니다.

`alert` 끝에 세미콜론을 추가해 다시 실행하면 코드는 잘 작동합니다.

```javascript
alert("제대로 동작합니다.");

[1, 2].forEach(alert)
```

“제대로 동작합니다.” 메시지 다음에 `1`과 `2`가 나타나는 것을 확인할 수 있죠.

세미콜론이 없을 때 에러가 발생했던 이유는 자바스크립트가 대괄호 `[...]`앞에는 세미콜론이 있다고 가정하지 않기 때문입니다.

따라서 세미콜론 자동 삽입이 일어나지 않고 첫 번째 예제는 단일 문으로 처리됩니다. 자바스크립트 엔진이 보게 될 코드는 다음과 같아지죠.

```javascript
alert("에러가 발생합니다.")[1, 2].forEach(alert)
```

하지만 원래 이 코드는 단일 문이 아닌 두 개의 서로 다른 문이었습니다. 문이 잘못 합쳐지면서 에러가 발생한 것이죠. 이 예제 외에도 이런 상황이 발생할 여지는 언제나 있습니다.

줄 바꿈으로 문을 나눴더라도, 문 사이엔 세미콜론을 넣는 것이 좋습니다. 자바스크립트 커뮤니티에서도 이를 규칙으로 정해 권장하고 있습니다. 다시 한번 정리하도록 하겠습니다. 세미콜론은 *생략할 수 있습니다.* 하지만 세미콜론을 사용하는 것이 더 안전하므로 이를 기억하고 따르도록 합시다. 입문자라면 이를 더 잘 지키도록 합시다.

## [주석](https://ko.javascript.info/structure#code-comments)

시간이 흐름에 따라 자바스크립트 프로그램은 더욱더 복잡해졌습니다. 이로 인해 무슨 일이 왜 벌어지고 있는지를 설명해주는 *주석(comment)* 의 필요성이 요구되었습니다.

주석은 스크립트의 어느 곳에나 작성할 수 있습니다. 자바스크립트 엔진은 주석을 무시하기 때문에 주석의 위치는 실행에 영향을 주지 않습니다.

**한 줄짜리 주석은 두 개의 슬래시 `//`로 시작됩니다.**

슬래시 뒤엔 주석을 적어주면 됩니다. 한 줄을 주석이 다 차지하는 형태도 있고 문 다음에 주석이 이어지는 형태도 있습니다.

아래와 같이 말이죠.

```javascript
// 이 주석은 한 줄을 다 차지합니다.
alert('Hello');

alert('World'); // 이 주석은 문 다음 이어집니다.
```

**여러 줄의 주석은 슬래시와 별표 `/\*`로 시작해 별표와 슬래시 `\*/`로 끝납니다.**

아래와 같이 말이죠.

```javascript
/* 두 줄짜리 주석 예제
이것은 여러 줄의 주석입니다.
*/
alert('Hello');
alert('World');
```

주석의 내용은 무시됩니다. 주석 `/* … */` 안에 코드가 들어가도 이 코드는 실행되지 않습니다.

이를 이용하면 코드 일부를 일시적으로 비활성화할 수 있습니다.

```javascript
/* 코드 주석 처리하기
alert('Hello');
*/
alert('World');
```

**단축키 사용하기**

대부분의 에디터는 주석 처리 단축키를 지원합니다. 블록을 지정하고 단축키를 누르면 원하는 코드를 주석 처리할 수 있죠. Ctrl+/ 를 사용하면 해당 줄의 코드를 한 줄짜리 주석으로 처리할 수 있으며, 여러 줄의 주석은 Ctrl+Shift+/ 를 통해 처리할 수 있습니다. Mac에서는 Ctrl 대신 Cmd를, Shift대신 Option을 사용하세요.

**중첩 주석은 지원하지 않습니다.**

`/*...*/`안에 또 다른 `/*...*/`이 있을 수 없습니다.

주석을 중첩해 쓰면 에러가 발생합니다.

```javascript
/*
  /* 중첩 주석 ?!? */
*/
alert( 'World' );
```

주석 달기를 두려워하지 마세요.

주석을 달면 코드의 전체적인 길이가 증가합니다. 하지만 이는 전혀 문제가 되지 않습니다. 프로덕션 서버에 배포하기 전에 코드를 압축해주는 도구가 많이 있고, 이 도구들은 주석을 삭제해주기 때문입니다. 실행 중인 스크립트엔 주석이 들어가지 않으므로, 주석은 최종으로 배포되는 코드에 부정적인 영향을 끼치지 않습니다.

# 2.3

# 엄격 모드

자바스크립트는 꽤 오랫동안 호환성 이슈 없이 발전해왔습니다. 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었죠.

덕분에 기존에 작성한 코드는 절대 망가지지 않는다는 장점이 있었습니다. 하지만 자바스크립트 창시자들이 했던 실수나 불완전한 결정이 언어 안에 영원히 박제된다는 단점도 생겼습니다.

이런 상황은 ECMAScript5(ES5)가 등장하기 전인 2009년까지 지속되었습니다. 그런데 새롭게 제정된 ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었습니다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있겠죠? 그래서 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었습니다. 대신 `use strict`라는 특별한 지시자를 사용해 엄격 모드(strict mode)를 활성화 했을 때만 이 변경사항이 활성화되게 해놓았습니다.

## [use strict](https://ko.javascript.info/strict-mode#ref-102)

지시자 `"use strict"`, 혹은 `'use strict'`는 단순한 문자열처럼 생겼습니다. 하지만 이 지시자가 스크립트 최상단에 오면 스크립트 전체가 “모던한” 방식으로 동작합니다.

예시:

```javascript
"use strict";

// 이 코드는 모던한 방식으로 실행됩니다.
...
```

명령어를 그룹화하는 방식인 함수에 대해선 곧 학습하도록 하겠습니다. 함수에 대해 학습하기 전에, `"use strict"`는 스크립트 최상단이 아닌 함수 본문 맨 앞에 올 수도 있다는 점을 알아두시기 바랍니다. 이렇게 하면 오직 해당 함수만 엄격 모드로 실행됩니다. 엄격 모드는 대개 스크립트 전체에 적용하지만 말이죠.

**"use strict"는 반드시 최상단에 위치시키세요.**

`"use strict"`는 스크립트 최상단에 있어야 한다는 점을 잊지 마세요. 그렇지 않으면 엄격 모드가 활성화되지 않을 수도 있습니다.

다음 코드에서는 엄격 모드가 활성화되지 않습니다.

```javascript
alert("some code");
// 하단에 위치한 "use strict"는 스크립트 상단에 위치하지 않으므로 무시됩니다.

"use strict";

// 엄격 모드가 활성화되지 않습니다.
```

`"use strict"`의 위에는 주석만 사용할 수 있습니다.

**`use strict`를 취소할 방법은 없습니다.**

자바스크립트 엔진을 이전 방식으로 되돌리는 `"no use strict"`같은 지시자는 존재하지 않습니다.

일단 엄격 모드가 적용되면 돌이킬 방법은 없습니다.

## [브라우저 콘솔](https://ko.javascript.info/strict-mode#ref-103)

개발한 기능을 테스트하기 위해 [브라우저 콘솔](https://ko.javascript.info/devtools)을 사용하는 경우, 기본적으로 `use strict`가 적용되어있지 않는다는 점에 주의하셔야 합니다.

`use strict`에 영향을 받는 경우라면 개발자는 기대하지 않았던 결과를 얻을 수 있기 때문입니다.

그렇다면 어떻게 해야 콘솔에서 `use strict`를 사용할 수 있을까요?

'use strict’를 입력한 후, `Shift+Enter키`를 눌러 줄 바꿈 해 원하는 스크립트를 입력하면 됩니다. 아래와 같이 말이죠.

```javascript
'use strict'; <Shift+Enter를 눌러 줄 바꿈 함>
//  ...테스트하려는 코드 입력
<Enter를 눌러 실행>
```

이 기능은 Firefox와 Chrome 같은 유명한 브라우저에서 대부분 사용 가능합니다.

브라우저가 오래 되어서 콘솔 창에 `use strict`를 입력하는 게 불가능하다면, `use strict`를 적용하는 가장 확실한 방법은 아래와 같이 코드를 래퍼로 감싸면 됩니다.

```javascript
(function() {
  'use strict';

  // ...테스트하려는 코드...
})()
```

## ['use strict’를 꼭 사용해야 하나요](https://ko.javascript.info/strict-mode#ref-104)

"당연히 사용해야 하는 거 아니야?"라는 생각이 드시겠지만, 꼭 그렇지만은 않습니다.

누군가는 스크립트 맨 윗줄엔 `"use strict"`를 넣는 게 좋다고 권유할 수 있습니다. 그런데 그거 아세요?

모던 자바스크립트는 '클래스’와 '모듈’이라 불리는 진일보한 구조를 제공합니다(클래스와 모듈에 대해선 당연히 뒤에서 학습할 예정입니다). 이 둘을 사용하면 `use strict`가 자동으로 적용되죠. 따라서 이 둘을 사용하고 있다면 스크립트에 `"use strict"`를 붙일 필요가 없습니다.

결론은 이렇습니다. **코드를 클래스와 모듈을 사용해 구성한다면 `"use strict"`를 생략해도 됩니다. 그런데 아직은 이 둘을 배우지 않았으니 `"use strict"`를 귀한 손님처럼 모시도록 하겠습니다.**

지금까지는 `use strict`의 일반적인 특징에 대해 알아보았습니다.

# 2.4

# 변수와 상수

대다수의 자바스크립트 애플리케이션은 사용자나 서버로부터 입력받은 정보를 처리하는 방식으로 동작합니다. 아래와 같이 말이죠.

1. 온라인 쇼핑몰 – 판매 중인 상품이나 장바구니 등의 정보
2. 채팅 애플리케이션 – 사용자 정보, 메시지 등의 정보

변수는 이러한 정보를 저장하는 용도로 사용됩니다.

## [변수](https://ko.javascript.info/variables#ref-78)

[변수(variable)](https://en.wikipedia.org/wiki/Variable_(computer_science))는 데이터를 저장할 때 쓰이는 ‘이름이 붙은 저장소’ 입니다. 온라인 쇼핑몰 애플리케이션을 구축하는 경우 상품이나 방문객 등의 정보를 저장할 때 변수를 사용하죠.

자바스크립트에선 `let` 키워드를 사용해 변수를 생성합니다.

아래 문(statement)은 'message’라는 이름을 가진 변수를 생성(*선언*)합니다.

```javascript
let message;
```

이제 할당 연산자 `=`를 사용해 변수 안에 데이터를 저장해 봅시다.

```javascript
let message;

message = 'Hello'; // 문자열을 저장합니다.
```

문자열이 변수와 연결된 메모리 영역에 저장되었기 때문에, 변수명을 이용해 문자열에 접근할 수 있게 되었습니다.

```javascript
let message;
message = 'Hello!';

alert(message); // 변수에 저장된 값을 보여줍니다.
```

아래와 같이 변수 선언과 값 할당을 한 줄에 작성할 수도 있습니다.

```javascript
let message = 'Hello!'; // 변수를 정의하고 값을 할당합니다.

alert(message); // Hello!
```

한 줄에 여러 변수를 선언하는 것도 가능합니다.

```javascript
let user = 'John', age = 25, message = 'Hello';
```

이렇게 작성하면 코드가 좀 더 짧아 보이긴 하지만 권장하는 방법은 아닙니다. 가독성을 위해 한 줄에는 하나의 변수를 작성해주세요.

한 줄에 한 개의 변수를 작성하면 코드가 길어 보이지만 읽기엔 편합니다.

```javascript
let user = 'John';
let age = 25;
let message = 'Hello';
```

어떤 사람들은 이런 방식으로도 변수를 정의합니다.

```javascript
let user = 'John',
  age = 25,
  message = 'Hello';
```

‘쉼표가 먼저 오는’ 방식으로 작성하는 사람도 있습니다.

```javascript
let user = 'John'
  , age = 25
  , message = 'Hello';
```

위에서 소개한 방식들에 기술적인 차이가 있지는 않습니다. 개인의 취향과 미적 감각에 따라 원하는 방식으로 코드를 작성하세요.

**`let` 대신 `var`**

만들어진 지 오래된 스크립트에서 `let` 대신 `var`라는 키워드를 발견하는 경우가 있습니다.

```javascript
var message = 'Hello';
```

`var`는 `let`과 *거의* 동일하게 동작합니다. `var`도 `let`처럼 변수를 선언하는 데 쓰이죠. 다만 `var`는 ‘오래된’ 방식입니다.

`let`과 `var`의 미묘한 차이점에 대해선 추후 [오래된 var](https://ko.javascript.info/var) 에서 자세히 다루도록 하겠습니다. 지금 시점에선 이 차이점이 중요하지 않기 때문에 넘어가도록 합시다.

## [현실 속의 비유](https://ko.javascript.info/variables#ref-79)

‘상자’ 안에 데이터를 저장하는데, 이 상자에는 특별한 이름표가 붙어 있다고 상상해 봅시다. 이렇게 하면 '변수’를 좀 더 쉽게 이해할 수 있습니다.

예를 들어, 변수 `message`는 `message`라는 이름표가 붙어있는 상자에 `"Hello!"`라는 값을 저장한 것이라고 생각할 수 있습니다.

상자 속엔 어떤 값이든지 넣을 수 있습니다.

원하는 만큼 값을 변경할 수도 있습니다.

```javascript
let message;

message = 'Hello!';

message = 'World!'; // 값이 변경되었습니다.

alert(message);
```

값이 변경되면, 이전 데이터는 변수에서 제거됩니다.

변수 두 개를 선언하고, 한 변수의 데이터를 다른 변수에 복사할 수도 있습니다.

```javascript
let Hello = 'Hello world!';

let message;

// Hello의 'Hello world' 값을 message에 복사합니다.
message = Hello;

// 이제 두 변수는 같은 데이터를 가집니다.
alert(Hello); // Hello world!
alert(message); // Hello world!
```

**변수를 두 번 선언하면 에러가 발생합니다.**

변수는 한 번만 선언해야 합니다.

같은 변수를 여러 번 선언하면 에러가 발생합니다.

```javascript
let message = "This";

// 'let'을 반복하면 에러가 발생합니다.
let message = "That"; // SyntaxError: 'message' has already been declared
```

따라서 변수는 딱 한 번만 선언하고, 선언한 변수를 참조할 때는 `let` 없이 변수명만 사용해 참조해야 합니다.

**함수형 언어**

[함수형(functional)](https://en.wikipedia.org/wiki/Functional_programming) 프로그래밍 언어는 변숫값 변경을 금지합니다. [스칼라(Scala)](http://www.scala-lang.org/)와 [얼랭(Erlang)](http://www.erlang.org/)은 대표적인 함수형 언어입니다.

이들 언어에서는 ‘상자 속에’ 값이 일단 저장되면, 그 값을 영원히 유지합니다. 다른 값을 저장하고 싶다면 새로운 상자를 만들어야(새 변수를 선언해야)만 합니다. 이전 변수를 재사용할 수 없습니다.

처음 봤을 땐 좀 이상해 보일 수 있지만, 함수형 언어는 중대한 개발에 상당히 적합한 언어입니다. 이런 제약이 장점으로 작용하는 병렬 계산(parallel computation)과 같은 영역도 있죠. 당장은 사용할 계획이 없더라도 이런 언어를 공부하는 것은 시야를 넓히는 데 도움이 되므로, 학습을 권유 드립니다.

## [변수 명명 규칙](https://ko.javascript.info/variables#ref-80)

자바스크립트에선 변수 명명 시 두 가지 제약 사항이 있습니다.

1. 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있습니다.
2. 첫 글자는 숫자가 될 수 없습니다.

다음은 유효한 변수명의 예시입니다.

```javascript
let userName;
let test123;
```

여러 단어를 조합하여 변수명을 만들 땐 [카멜 표기법(camelCase)](https://en.wikipedia.org/wiki/CamelCase)이 흔히 사용됩니다. 카멜 표기법은 단어를 차례대로 나열하면서 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성합니다. `myVeryLongName`같이 말이죠.

달러 기호 `'$'` 와 밑줄 `'_'` 를 변수명에 사용할 수 있다는 점이 조금 특이하네요. 이 특수 기호는 일반 글자처럼 특별한 의미를 지니진 않습니다.

아래는 유효한 변수명에 관한 예시입니다.

```javascript
let $ = 1; // '$'라는 이름의 변수를 선언합니다.
let _ = 2; // '_'라는 이름의 변수를 선언합니다.

alert($ + _); // 3
```

아래는 잘못된 변수명의 예시입니다.

```javascript
let 1a; // 변수명은 숫자로 시작해선 안 됩니다.

let my-name; // 하이픈 '-'은 변수명에 올 수 없습니다.
```

**대·소문자 구별**

`apple`와 `AppLE`은 서로 다른 변수입니다.

**비 라틴계 언어도 변수명에 사용할 수 있지만 권장하진 않습니다.**

키릴 문자, 심지어 상형문자도 변수명에 사용할 수 있습니다. 모든 언어를 변수명에 사용할 수 있죠.

```javascript
let имя = '...';
let 我 = '...';
```

위 코드에는 기술적인 에러가 없습니다. 변수명도 유효합니다. 하지만 영어를 변수명에 사용하는 것이 국제적인 관습이므로, 변수명은 영어를 사용해서 만들길 권유 드립니다. 다른 나라 사람이 스크립트를 볼 경우 등을 대비해 장기적인 안목을 가지고 코드를 작성합시다.

**예약어**

[예약어(reserved name) 목록](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords)에 있는 단어는 변수명으로 사용할 수 없습니다. 이 단어들은 자바스크립트 내부에서 이미 사용 중이기 때문입니다.

예약어 예시: `let`, `class`, `return`, `function`

아래 코드는 문법 에러를 발생시킵니다.

```javascript
let let = 5; // 'let'을 변수명으로 사용할 수 없으므로 에러!
let return = 5; // 'return'을 변수명으로 사용할 수 없으므로 에러!
```

**`use strict` 없이 할당하기**

변수는 대개 정의되어 있어야 사용할 수 있습니다. 그러나 예전에는 `let` 없이도 단순하게 값을 할당해 변수를 생성하는 것이 가능했습니다. `use strict`를 쓰지 않으면 과거 스크립트와의 호환성을 유지할 수 있기 때문에 여전히 이 방식을 사용할 수 있습니다.

```javascript
// 참고: 이 예제에는 "use strict"가 없습니다.

num = 5; // 변수 'num'이 정의되어있지 않더라도, 단순 할당만으로 변수가 생성됩니다.

alert(num); // 5
```

이렇게 변수를 생성하는 것은 나쁜 관습입니다. 엄격 모드에서 에러를 발생시키기 때문이죠.

```javascript
"use strict";

num = 5; // error: num is not defined
```

## [상수](https://ko.javascript.info/variables#ref-81)

변화하지 않는 변수를 선언할 땐, `let` 대신 `const`를 사용합니다.

```javascript
const myBirthday = '18.04.1982';
```

이렇게 `const`로 선언한 변수를 '상수(constant)'라고 부릅니다. 상수는 재할당할 수 없으므로 상수를 변경하려고 하면 에러가 발생합니다.

```javascript
const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // error, can't reassign the constant!
```

변숫값이 절대 변경되지 않을 것이라 확신하면, 값이 변경되는 것을 방지하면서 다른 개발자들에게 이 변수는 상수라는 것을 알리기 위해 `const`를 사용해 변수를 선언하도록 합시다.

### [대문자 상수](https://ko.javascript.info/variables#ref-82)

기억하기 힘든 값을 변수에 할당해 별칭으로 사용하는 것은 널리 사용되는 관습입니다.

이런 상수는 대문자와 밑줄로 구성된 이름으로 명명합니다.

예시로 웹에서 사용하는 색상 표기법인 16진수 컬러 코드에 대한 상수를 한번 만들어보겠습니다.

```javascript
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// 색상을 고르고 싶을 때 별칭을 사용할 수 있게 되었습니다.
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

대문자로 상수를 만들어 사용하면 다음과 같은 장점이 있습니다.

- `COLOR_ORANGE`는 `"#FF7F00"`보다 기억하기가 훨씬 쉽습니다.
- `COLOR_ORANGE`를 사용하면 `"#FF7F00"`를 사용하는 것보다 오타를 낼 확률이 낮습니다.
- `COLOR_ORANGE`가 `#FF7F00`보다 훨씬 유의미하므로, 코드 가독성이 증가합니다.

그렇다면 언제 일반적인 방식으로 상수를 명명하고, 언제 대문자를 사용해서 명명해야 하는 걸까요? 명확히 짚고 넘어갑시다.

'상수’는 변수의 값이 절대 변하지 않음을 의미합니다. 그중에는 (빨간색을 나타내는 16진수 값처럼) 코드가 실행되기 전에 이미 그 값을 알고 있는 상수도 있고, 런타임 과정에서 *계산되지만* 최초 할당 이후 값이 변하지 않는 상수도 있습니다.

예시:

```javascript
const pageLoadTime = /* 웹페이지를 로드하는데 걸린 시간 */;
```

`pageLoadTime`의 값은 페이지가 로드되기 전에는 정해지지 않기 때문에 일반적인 방식으로 변수명을 지었습니다. 하지만 이 값은 최초 할당 이후에 변경되지 않으므로 여전히 상수입니다.

정리하자면, 대문자 상수는 ‘하드 코딩한’ 값의 별칭을 만들 때 사용하면 됩니다.

## [바람직한 변수명](https://ko.javascript.info/variables#ref-83)

변수에 관한 매우 중요한 사실이 한 가지 더 있습니다.

변수명은 간결하고, 명확해야 합니다. 변수가 담고있는 것이 무엇인지 잘 설명할 수 있어야 하죠.

변수의 이름을 짓는 것은 프로그래밍에서 가장 중요하고 복잡한 기술 중 하나입니다. 변수명만 슬쩍 봐도 초보자가 코드를 작성했는지, 노련한 개발자가 작성했는지 알 수 있습니다.

실제 프로젝트에선 맨 처음부터 완전히 독립적인 코드를 작성하기보다 기존 코드의 틀을 변경하고 확장하는데 대부분의 시간을 보냅니다. 작성했던 코드를 얼마 후에 다시 봤을 때, 정보에 알맞은 이름이 적혀있으면 정보를 더 쉽게 찾을 수 있습니다. 다시 말해, 변수가 올바른 이름을 가졌을 때 말이죠.

그러므로 변수를 선언하기 전에 내가 지은 변수의 이름이 괜찮은지 숙고해 주시기 바랍니다.

아래는 변수 명명 시 참고하기 좋은 규칙입니다.

- `userName` 이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용하세요.
- 무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 `a`, `b`, `c`와 같은 짧은 이름은 피하세요.
- 최대한 서술적이고 간결하게 명명해 주세요. `data`와 `value`는 나쁜 이름의 예시입니다. 이런 이름은 아무것도 설명해주지 않습니다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용합시다.
- 자신만의 규칙이나 소속된 팀의 규칙을 따르세요. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 `currentVisitor`나 `newManInTown`이 아닌 `currentUser`나 `newUser`라는 이름으로 지어야 합니다.

간단해 보이나요? 그렇게 보이긴 합니다. 그러나 실전에서 서술적이고 간결한 변수명을 짓는 것은 간단하지 않습니다. 그럼, 화이팅!

**재사용 아니면 새로 만들기?**

개발자 중에는 새로운 변수를 선언하기보다 기존 변수를 재사용 하는 걸 선호하는 게으른 분들이 있습니다.

재사용된 변수는 과거에 붙여진 스티커를 떼지 않은 채 물건만 바뀐 상자와 같습니다. 상자 안에는 무엇이 들어 있을까요? 내용물에 대한 정보를 알고 있는 사람은 누구인가요? 이를 알기 위해선 상자에 가까이 다가가 확인해야만 합니다.

변수를 재사용하면 변수 선언에 쏟는 노력을 좀 덜 순 있겠지만, 디버깅에 열 배 더 많은 시간을 쏟아야 합니다.

변수를 추가하는 것은 악습이 아닙니다. 좋은 습관입니다.

모던 자바스크립트 압축기(minifier)와 브라우저는 코드 최적화를 잘해줍니다. 변수를 추가한다고 해서 성능 이슈가 생기지 않죠. 값이 다른 경우, 변수를 다르게 선언해 주면 코드 최적화에 도움이 될 수도 있습니다.

## [요약](https://ko.javascript.info/variables#ref-84)

`var`, `let`, `const`를 사용해 변수를 선언할 수 있습니다. 선언된 변수엔 데이터를 저장할 수 있죠.

- `let` – 모던한 변수 선언 키워드입니다.
- `var` – 오래된 변수 선언 키워드입니다. 잘 사용하지 않습니다. `let`과의 미묘한 차이점은 [오래된 var](https://ko.javascript.info/var) 챕터에서 다루도록 하겠습니다.
- `const` – `let`과 비슷하지만, 변수의 값을 변경할 수 없습니다.

# 2.5

# 자료형

자바스크립트에서 값은 항상 문자열이나 숫자형 같은 특정한 자료형에 속합니다.

자바스크립트에는 여덟 가지 기본 자료형이 있습니다. 이번 챕터에선 이 자료형 모두를 개괄적으로 다루도록 하겠습니다. 각 자료형에 대한 세부 사항들은 이어지는 챕터에서 다룰 예정입니다.

자바스크립트의 변수는 자료형에 관계없이 모든 데이터일 수 있습니다. 따라서 변수는 어떤 순간에 문자열일 수 있고 다른 순간엔 숫자가 될 수도 있습니다.

```javascript
// no error
let message = "hello";
message = 123456;
```

이처럼 자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있는 언어를 ‘동적 타입(dynamically typed)’ 언어라고 부릅니다.

## [숫자형](https://ko.javascript.info/types#ref-717)

```javascript
let n = 123;
n = 12.345;
```

*숫자형(number type)* 은 정수 및 부동소수점 숫자(floating point number)를 나타냅니다.

숫자형과 관련된 연산은 다양한데, 곱셈 `*`, 나눗셈 `/`, 덧셈 `+`, 뺄셈 `-` 등이 대표적입니다.

숫자형엔 일반적인 숫자 외에 `Infinity`, `-Infinity`, `NaN`같은 '특수 숫자 값(special numeric value)'이 포함됩니다.

- `Infinity`는 어떤 숫자보다 더 큰 특수 값, [무한대(∞)](https://en.wikipedia.org/wiki/Infinity)를 나타냅니다.

  어느 숫자든 0으로 나누면 무한대를 얻을 수 있습니다.

  ```javascript
  alert( 1 / 0 ); // 무한대
  ```

  `Infinity`를 직접 참조할 수도 있습니다.

  ```javascript
  alert( Infinity ); // 무한대
  ```

- `NaN`은 계산 중에 에러가 발생했다는 것을 나타내주는 값입니다. 부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중에 에러가 발생하는데, 이때 `NaN`이 반환됩니다.

  ```javascript
  alert( "숫자가 아님" / 2 ); // NaN, 문자열을 숫자로 나누면 오류가 발생합니다.
  ```

  `NaN`은 여간해선 바뀌지 않습니다. `NaN`에 어떤 추가 연산을 해도 결국 `NaN`이 반환됩니다.

  ```javascript
  alert( "숫자가 아님" / 2 + 5 ); // NaN
  ```

  연산 과정 어디에선가 `NaN`이 반환되었다면, 이는 모든 결과에 영향을 미칩니다.

**수학 연산은 안전합니다.**

자바스크립트에서 행해지는 수학 연산은 '안전’하다고 볼 수 있습니다. 0으로 나눈다거나 숫자가 아닌 문자열을 숫자로 취급하는 등의 이례적인 연산이 자바스크립트에선 가능합니다.

말이 안 되는 수학 연산을 하더라도 스크립트는 치명적인 에러를 내뿜으며 죽지 않습니다. `NaN`을 반환하며 연산이 종료될 뿐입니다.

현실에선 특수 숫자 값을 숫자로 취급하진 않습니다. 하지만 자바스크립트에선 특수 숫자 값을 숫자형으로 분류합니다.

숫자를 다루는 방법에 대해선 [숫자형](https://ko.javascript.info/number) 챕터에서 자세히 알아보도록 하겠습니다.

## [BigInt](https://ko.javascript.info/types#ref-718)

내부 표현 방식 때문에 자바스크립트에선 `(253-1)`(`9007199254740991`) 보다 큰 값 혹은 `-(253-1)` 보다 작은 정수는 '숫자형’을 사용해 나타낼 수 없습니다.

사실 대부분의 상황에서 이런 제약사항은 문제가 되지 않습니다. 그렇지만 암호 관련 작업같이 아주 큰 숫자가 필요한 상황이거나 아주 높은 정밀도로 작업을 해야 할 때는 이런 큰 숫자가 필요합니다.

`BigInt`형은 표준으로 채택된 지 얼마 안 된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있습니다.

`BigInt`형 값은 정수 리터럴 끝에 `n`을 붙이면 만들 수 있습니다.

```javascript
// 끝에 'n'이 붙으면 BigInt형 자료입니다.
const bigInt = 1234567890123456789012345678901234567890n;
```

`BigInt`형 숫자는 자주 쓰이지 않기 때문에 여기서 자세히 다루지 않고 별도의 챕터, [BigInt](https://ko.javascript.info/bigint)에서 설명드리겠습니다. 아주 큰 숫자를 사용해야 하는 경우라면 해당 챕터를 참고해 주시기 바랍니다.

**호환성 이슈**

이 글이 작성된 시점엔 Firefox, Chrome, Edge, Safari에서만 `BigInt`를 지원합니다. IE에선 지원하지 않습니다.

## [문자형](https://ko.javascript.info/types#ref-719)

자바스크립트에선 문자열(string)을 따옴표로 묶습니다.

```javascript
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
```

따옴표는 세 종류가 있습니다.

1. 큰따옴표: `"Hello"`
2. 작은따옴표: `'Hello'`
3. 역 따옴표(백틱, backtick): ``Hello``

큰따옴표와 작은따옴표는 ‘기본적인’ 따옴표로, 자바스크립트에서는 이 둘에 차이를 두지 않습니다.

역 따옴표로 변수나 표현식을 감싼 후 `${…}`안에 넣어주면, 아래와 같이 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 있습니다.

```javascript
let name = "John";

// 변수를 문자열 중간에 삽입
alert( `Hello, ${name}!` ); // Hello, John!

// 표현식을 문자열 중간에 삽입
alert( `the result is ${1 + 2}` ); // the result is 3
```

`${…}` 안에는 `name` 같은 변수나 `1 + 2` 같은 수학 관련 표현식을 넣을 수 있습니다. 물론 더 복잡한 표현식도 넣을 수 있죠. 무엇이든 들어갈 수 있습니다. 이렇게 문자열 중간에 들어간 변수나 표현식은 평가가 끝난 후 문자열의 일부가 됩니다.

큰따옴표나 작은따옴표를 사용하면 중간에 표현식을 넣을 수 없다는 점에 주의하시기 바랍니다. 이 방법은 역 따옴표를 써야만 가능합니다.

```javascript
alert( "the result is ${1 + 2}" ); // the result is ${1 + 2} (큰따옴표는 확장 기능을 지원하지 않습니다.)
```

문자열은 [문자열](https://ko.javascript.info/string)챕터에서 더 자세히 다루도록 하겠습니다.

***글자형\*은 없습니다.**

일부 언어는 글자 하나를 저장할 때 쓰이는 자료형, '글자(character)'형을 따로 지원합니다. C 언어와 Java의 `char`가 대표적인 예입니다.

자바스크립트는 글자형을 지원하지 않습니다. `문자형`만 있을 뿐입니다. 여기엔 글자가 하나 혹은 여러 개 들어갈 수 있습니다.

## [불린형](https://ko.javascript.info/types#ref-720)

불린형(논리 타입)은 `true`와 `false` 두 가지 값밖에 없는 자료형입니다.

불린형은 긍정(yes)이나 부정(no)을 나타내는 값을 저장할 때 사용합니다. `true`는 긍정, `false`는 부정을 의미합니다.

예시:

```javascript
let nameFieldChecked = true; // 네, name field가 확인되었습니다(checked).
let ageFieldChecked = false; // 아니요, age field를 확인하지 않았습니다(not checked)
```

불린값은 비교 결과를 저장할 때도 사용됩니다.

```javascript
let isGreater = 4 > 1;

alert( isGreater ); // true (비교 결과: "yes")
```

불린형에 대한 자세한 사항들은 [논리 연산자](https://ko.javascript.info/logical-operators) 챕터에서 다루도록 하겠습니다.

## [‘null’ 값](https://ko.javascript.info/types#ref-721)

`null` 값은 지금까지 소개한 자료형 중 어느 자료형에도 속하지 않는 값입니다.

`null` 값은 오로지 `null` 값만 포함하는 별도의 자료형을 만듭니다.

```javascript
let age = null;
```

자바스크립트의 `null`은 자바스크립트 이외 언어의 `null`과 성격이 다릅니다. 다른 언어에선 `null`을 '존재하지 않는 객체에 대한 참조’나 '널 포인터(null pointer)'를 나타낼 때 사용합니다.

하지만 자바스크립트에선 `null`을 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용합니다.

`let age = null;`은 `나이(age)`를 알 수 없거나 그 값이 비어있음을 보여줍니다.

## [‘undefined’ 값](https://ko.javascript.info/types#ref-722)

`undefined` 값도 `null` 값처럼 자신만의 자료형을 형성합니다.

`undefined`는 '값이 할당되지 않은 상태’를 나타낼 때 사용합니다.

변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined`가 자동으로 할당됩니다.

```javascript
let age;

alert(age); // 'undefined'가 출력됩니다.
```

개발자가 변수에 `undefined`를 명시적으로 할당하는 것도 가능하긴 합니다.

```javascript
let age = 100;

// 값을 undefined로 바꿉니다.
age = undefined;

alert(age); // "undefined"
```

하지만 이렇게 `undefined`를 직접 할당하는 걸 권장하진 않습니다. 변수가 ‘비어있거나’ ‘알 수 없는’ 상태라는 걸 나타내려면 `null`을 사용하세요. `undefined`는 값이 할당되지 않은 변수의 초기값을 위해 예약어로 남겨둡시다.

## [객체와 심볼](https://ko.javascript.info/types#ref-723)

`객체(object)`형은 특수한 자료형입니다.

객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부릅니다. 반면 객체는 데이터 컬렉션이나 복잡한 개체(entity)를 표현할 수 있습니다.

이런 특징 때문에 자바스크립트에서 객체는 좀 더 특별한 취급을 받습니다. 자세한 내용은 원시형을 배우고 난 후 [객체](https://ko.javascript.info/object)에서 다루도록 하겠습니다.

`심볼(symbol)`형은 객체의 고유한 식별자(unique identifier)를 만들 때 사용됩니다. 심볼형에 대해선 객체를 학습하고 난 이후에 자세히 알아보겠습니다.

## [typeof 연산자](https://ko.javascript.info/types#type-typeof)

`typeof` 연산자는 인수의 자료형을 반환합니다. 자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 빠르게 알아내고자 할 때 유용합니다.

`typeof` 연산자는 두 가지 형태의 문법을 지원합니다.

1. 연산자: `typeof x`
2. 함수: `typeof(x)`

괄호가 있든 없든 결과가 동일합니다.

`typeof x`를 호출하면 인수의 자료형을 나타내는 문자열을 반환합니다.

```javascript
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
```

마지막 세 줄은 약간의 설명이 필요해 보이네요.

1. `Math`는 수학 연산을 제공하는 내장 객체이므로 `"object"`가 출력됩니다. `Math`에 대해선 [숫자형](https://ko.javascript.info/number) 챕터에서 학습하도록 하겠습니다. 내장 객체는 객체형이라는 것을 알려주기 위해 이런 예시를 작성해 보았습니다.
2. `typeof null`의 결과는 `"object"`입니다. `null`은 별도의 고유한 자료형을 가지는 특수 값으로 객체가 아니지만, 하위 호환성을 유지하기 위해 이런 오류를 수정하지 않고 남겨둔 상황입니다. 언어 자체의 오류이므로 `null`이 객체가 아님에 유의하시기 바랍니다.
3. `typeof`는 피연산자가 함수면 `"function"`을 반환합니다. 그러므로 `typeof alert`는 `"function"`을 출력해줍니다. 그런데 '함수’형은 따로 없습니다. 함수는 객체형에 속합니다. 이런 동작 방식이 형식적으론 잘못되긴 했지만, 아주 오래전에 만들어진 규칙이었기 때문에 하위 호환성 유지를 위해 남겨진 상태입니다. 한편, 실무에선 이런 특징이 매우 유용하게 사용되기도 합니다.

## [요약](https://ko.javascript.info/types#ref-724)

자바스크립트에는 여덟 가지 기본 자료형이 있습니다.

- `숫자형` – 정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용합니다. 정수의 한계는 ±253 입니다.
- `bigint` – 길이 제약 없이 정수를 나타낼 수 있습니다.
- `문자형` – 빈 문자열이나 글자들로 이뤄진 문자열을 나타낼 때 사용합니다. 단일 문자를 나타내는 별도의 자료형은 없습니다.
- `불린형` – `true`, `false`를 나타낼 때 사용합니다.
- `null` – `null` 값만을 위한 독립 자료형입니다. `null`은 알 수 없는 값을 나타냅니다.
- `undefined` – `undefined` 값만을 위한 독립 자료형입니다. `undefined`는 할당되지 않은 값을 나타냅니다.
- `객체형` – 복잡한 데이터 구조를 표현할 때 사용합니다.
- `심볼형` – 객체의 고유 식별자를 만들 때 사용합니다.

`typeof` 연산자는 피연산자의 자료형을 알려줍니다.

- `typeof x` 또는 `typeof(x)` 형태로 사용합니다.
- 피연산자의 자료형을 문자열 형태로 반환합니다.
- `null`의 typeof 연산은 `"object"`인데, 이는 언어상 오류입니다. null은 객체가 아닙니다.

# 2.6

# alert, prompt, confirm을 이용한 상호작용

브라우저를 데모 환경으로 사용 중이므로 브라우저 환경에서 사용되는 최소한의 사용자 인터페이스 기능인 `alert`, `prompt`, `confirm`에 대해 알아보겠습니다.

## [alert](https://ko.javascript.info/alert-prompt-confirm#ref-90)

`alert` 함수는 앞선 예제에서 살펴본 바 있습니다. 이 함수가 실행되면 사용자가 ‘확인(OK)’ 버튼을 누를 때까지 메시지를 보여주는 창이 계속 떠있게 됩니다.

예시를 살펴봅시다.

```javascript
alert("Hello");
```

메시지가 있는 작은 창은 *모달 창(modal window)* 이라고 부릅니다. '모달’이란 단어엔 페이지의 나머지 부분과 상호 작용이 불가능하다는 의미가 내포되어 있습니다. 따라서 사용자는 모달 창 바깥에 있는 버튼을 누른다든가 하는 행동을 할 수 없습니다. 확인 버튼을 누르기 전까지 말이죠.

## [prompt](https://ko.javascript.info/alert-prompt-confirm#ref-91)

브라우저에서 제공하는 `prompt` 함수는 두 개의 인수를 받습니다.

```javascript
result = prompt(title, [default]);
```

함수가 실행되면 텍스트 메시지와 입력 필드(input field), 확인(OK) 및 취소(Cancel) 버튼이 있는 모달 창을 띄워줍니다.

- `title`

  사용자에게 보여줄 문자열

- `default`

  입력 필드의 초깃값(선택값)

**인수를 감싸는 대괄호 `[...]`의 의미**

`default`를 감싸는 대괄호는 이 매개변수가 필수가 아닌 선택값이라는 것을 의미합니다.

사용자는 프롬프트 대화상자의 입력 필드에 원하는 값을 입력하고 확인을 누를 수 있습니다. 값을 입력하길 원하지 않는 경우는 취소(Cancel) 버튼을 누르거나 Esc를 눌러 대화상자를 빠져나가면 됩니다.

`prompt` 함수는 사용자가 입력 필드에 기재한 문자열을 반환합니다. 사용자가 입력을 취소한 경우는 `null`이 반환됩니다.

예시:

```javascript
let age = prompt('나이를 입력해주세요.', 100);

alert(`당신의 나이는 ${age}살 입니다.`); // 당신의 나이는 100살입니다.
```

**Internet Explorer(IE)에서는 항상 '기본값’을 넣어주세요.**

프롬프트 함수의 두 번째 매개변수는 선택사항이지만, 이 매개변수가 없는 경우 IE는 `"undefined"`를 입력 필드에 명시합니다.

아래 코드를 IE에서 실행해 보세요.

```javascript
let test = prompt("Test");
```

IE 사용자를 비롯한 모든 사용자에게 깔끔한 프롬프트를 보여주려면 아래와 같이 두 번째 매개변수를 항상 전달해 줄 것을 권장합니다.

```javascript
let test = prompt("Test", ''); // <-- IE 사용자를 위한 매개변수 처리
```

## [컨펌 대화상자](https://ko.javascript.info/alert-prompt-confirm#ref-92)

문법:

```javascript
result = confirm(question);
```

`confirm` 함수는 매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여줍니다.

사용자가 확인 버튼을 누르면 `true`, 그 외의 경우는 `false`를 반환합니다.

예시:

```javascript
let isBoss = confirm("당신이 주인인가요?");

alert( isBoss ); // 확인 버튼을 눌렀다면 true가 출력됩니다.
```

## [요약](https://ko.javascript.info/alert-prompt-confirm#ref-93)

브라우저는 사용자와 상호작용할 수 있는 세 가지 함수를 제공합니다.

- `alert`

  메시지를 보여줍니다.

- `prompt`

  사용자에게 텍스트를 입력하라는 메시지를 띄워줌과 동시에, 입력 필드를 함께 제공합니다. 확인을 누르면 `prompt` 함수는 사용자가 입력한 문자열을 반환하고, 취소 또는 Esc를 누르면 `null`을 반환합니다.

- `confirm`

  사용자가 확인 또는 취소 버튼을 누를 때까지 메시지가 창에 보여집니다. 사용자가 확인 버튼을 누르면 `true`를, 취소 버튼이나 Esc를 누르면 `false`를 반환합니다.

위 함수들은 모두 모달 창을 띄워주는데, 모달 창이 떠 있는 동안은 스크립트의 실행이 일시 중단됩니다. 사용자가 창을 닫기 전까진 나머지 페이지와 상호 작용이 불가능합니다.

지금까지 살펴본 세 함수엔 두 가지 제약사항이 있습니다.

1. 모달 창의 위치는 브라우저가 결정하는데, 대개 브라우저 중앙에 위치합니다.
2. 모달 창의 모양은 브라우저마다 다릅니다. 개발자는 창의 모양을 수정할 수 없습니다.

이런 제약사항은 간결성을 위해 치러야 할 대가입니다. 창을 더 멋지게 꾸미고 복잡한 상호작용을 가능하게 해주는 다른 방법도 있긴 하지만, '멋을 위한 부가 기능’이 필요하지 않다면 지금까지 소개해드린 기본 메서드만으로 충분합니다.

# 2.7

# 형 변환

함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환됩니다. 이런 과정을 "형 변환(type conversion)"이라고 합니다.

`alert`가 전달받은 값의 자료형과 관계없이 이를 문자열로 자동 변환하여 보여주는 것이나, 수학 관련 연산자가 전달받은 값을 숫자로 변환하는 경우가 형 변환의 대표적인 예시입니다.

이 외에, 전달받은 값을 의도를 갖고 원하는 타입으로 변환(명시적 변환)해 주는 경우도 형 변환이라고 할 수 있습니다.

**객체의 형변환은 나중에 다룹니다.**

이 챕터에선 객체는 다루지 않겠습니다. 여기선 원시형의 형변환에 대해서만 다룰 예정입니다.

객체의 형 변환이 어떻게 이뤄지는지 [객체를 원시형으로 변환하기](https://ko.javascript.info/object-toprimitive)에 대해선 객체에 대한 학습이 끝난 후 알아보겠습니다.

## [문자형으로 변환](https://ko.javascript.info/type-conversions#ref-675)

문자형으로의 형 변환은 문자형의 값이 필요할 때 일어납니다.

`alert`메서드는 매개변수로 문자형을 받기 때문에, `alert(value)`에서 value는 문자형이어야 합니다. 만약, 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변환됩니다.

`String(value)` 함수를 호출해 전달받은 값을 문자열로 변환 할 수도 있습니다.

```javascript
let value = true;
alert(typeof value); // boolean

value = String(value); // 변수 value엔 문자열 "true"가 저장됩니다.
alert(typeof value); // string
```

`false`는 문자열 `"false"`로, `null`은 문자열 `"null"`로 변환되는 것과 같이, 문자형으로의 변환은 대부분 예측 가능한 방식으로 일어납니다.

## [숫자형으로 변환](https://ko.javascript.info/type-conversions#ref-676)

숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어납니다.

숫자형이 아닌 값에 나누기 `/`를 적용한 경우와 같이 말이죠.

```javascript
alert( "6" / "2" ); // 3, 문자열이 숫자형으로 자동변환된 후 연산이 수행됩니다.
```

`Number(value)` 함수를 사용하면 주어진 값(`value`)을 숫자형으로 명시해서 변환할 수 있습니다.

```javascript
let str = "123";
alert(typeof str); // string

let num = Number(str); // 문자열 "123"이 숫자 123으로 변환됩니다.

alert(typeof num); // number
```

숫자형 값을 사용해 무언가를 하려고 하는데 그 값을 문자 기반 폼(form)을 통해 입력받는 경우엔, 이런 명시적 형 변환이 필수입니다.

한편, 숫자 이외의 글자가 들어가 있는 문자열을 숫자형으로 변환하려고 하면, 그 결과는 `NaN`이 됩니다. 예시를 살펴봅시다.

```javascript
let age = Number("임의의 문자열 123");

alert(age); // NaN, 형 변환이 실패합니다.
```

아래는 숫자형으로 변환 시 적용되는 규칙입니다.

| 전달받은 값      | 형 변환 후                                                   |
| :--------------- | :----------------------------------------------------------- |
| `undefined`      | `NaN`                                                        |
| `null`           | `0`                                                          |
| `true and false` | `1` 과 `0`                                                   |
| `string`         | 문자열의 처음과 끝 공백이 제거됩니다. 공백 제거 후 남아있는 문자열이 없다면 `0`, 그렇지 않다면 문자열에서 숫자를 읽습니다. 변환에 실패하면 `NaN`이 됩니다. |

예시:

```javascript
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN ("z"를 숫자로 변환하는 데 실패함)
alert( Number(true) );        // 1
alert( Number(false) );       // 0
```

`null`과 `undefined`는 숫자형으로 변환 시 결과가 다르다는 점에 유의하시기 바랍니다. `null`은 `0`이 되고 `undefined`는 `NaN`이 됩니다.

대부분의 수학 연산은 형 변환을 수반합니다. 자세한 내용은 다음 챕터에서 살펴보겠습니다.

## [불린형으로 변환](https://ko.javascript.info/type-conversions#ref-677)

불린형으로의 변환은 아주 간단합니다.

이 형 변환은 논리 연산을 수행할 때 발생합니다(논리 연산에 관한 내용은 뒤 챕터에서 다루고 있습니다). `Boolean(value)`를 호출하면 명시적으로 불리언으로의 형 변환을 수행할 수 있습니다.

불린형으로 변환 시 적용되는 규칙은 다음과 같습니다.

- 숫자 `0`, 빈 문자열, `null`, `undefined`, `NaN`과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 `false`가 됩니다.
- 그 외의 값은 `true`로 변환됩니다.

예시:

```javascript
alert( Boolean(1) ); // 숫자 1(true)
alert( Boolean(0) ); // 숫자 0(false)

alert( Boolean("hello") ); // 문자열(true)
alert( Boolean("") ); // 빈 문자열(false)
```

**주의: 문자열 `"0"`은 `true`입니다.**

PHP 등의 일부 언어에선 문자열 `"0"`을 `false`로 취급합니다. 그러나 자바스크립트에선 비어 있지 않은 문자열은 언제나 `true`입니다.

```javascript
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // 공백이 있는 문자열도 비어있지 않은 문자열이기 때문에 true로 변환됩니다.
```

## [요약](https://ko.javascript.info/type-conversions#ref-678)

문자, 숫자, 논리형으로의 형 변환은 자주 일어나는 형 변환입니다.

**`문자형으로 변환`** 은 무언가를 출력할 때 주로 일어납니다. `String(value)`을 사용하면 문자형으로 명시적 변환이 가능합니다. 원시 자료형을 문자형으로 변환할 땐, 대부분 그 결과를 예상할 수 있을 정도로 명시적인 방식으로 일어납니다.

**`숫자형으로 변환`** 은 수학 관련 연산시 주로 일어납니다. `Number(value)`로도 형 변환을 할 수 있습니다.

숫자형으로의 변환은 다음 규칙을 따릅니다.

| 전달받은 값    | 형 변환 후                                                   |
| :------------- | :----------------------------------------------------------- |
| `undefined`    | `NaN`                                                        |
| `null`         | `0`                                                          |
| `true / false` | `1 / 0`                                                      |
| `string`       | 전달받은 문자열을 “그대로” 읽되, 처음과 끝의 공백을 무시합니다. 문자열이 비어있다면 `0`이 되고, 오류 발생 시 `NaN`이 됩니다. |

**`불린형으로 변환`** 은 논리 연산 시 발생합니다. `Boolean(value)`으로도 변환할 수 있습니다.

불린형으로의 형 변환은 다음 규칙을 따릅니다.

| 전달받은 값                           | 형 변환 후 |
| :------------------------------------ | :--------- |
| `0`, `null`, `undefined`, `NaN`, `""` | `false`    |
| 그 외의 값                            | `true`     |

형 변환 시 적용되는 규칙 대부분은 이해하고 기억하기 쉬운 편에 속합니다. 다만 아래는 예외적인 경우이기 때문에 실수를 방지하기 위해 따로 기억해 두도록 합시다.

- 숫자형으로 변환 시 `undefined`는 `0`이 아니라 `NaN`이 됩니다.
- 문자열 `"0"`과 `" "`같은 공백은 불린형으로 변환 시 true가 됩니다.

# 2.8

# 기본 연산자와 수학

덧셈 `+`, 곱셈 `*`, 뺄셈 `-`과 같은 연산은 학교에서 배워서 이미 알고 계실 겁니다.

이번 챕터에서는 이런 기본 연산자를 시작으로 학교에선 다루지 않았던 자바스크립트에서만 제공하는 연산자에 대해 배워보겠습니다.

## [용어: ‘단항’, ‘이항’, ‘피연산자’](https://ko.javascript.info/operators#ref-95)

연산자에 대해 학습하기 전에, 앞으로 자주 등장하게 될 용어 몇 가지를 정리해 보겠습니다.

- *피연산자(operand)* 는 연산자가 연산을 수행하는 대상입니다. `5 * 2`에는 왼쪽 피연산자 `5`와 오른쪽 피연산자 `2`, 총 두 개의 피연산자가 있습니다. '피연산자’는 '인수(argument)'라는 용어로 불리기도 합니다.

- 피연산자를 하나만 받는 연산자는 *단항(unary) 연산자* 라고 부릅니다. 피연산자의 부호를 뒤집는 단항 마이너스 연산자 `-`는 단항 연산자의 대표적인 예입니다.

  ```javascript
  let x = 1;
  
  x = -x;
  alert( x ); // -1, 단항 마이너스 연산자는 부호를 뒤집습니다.
  ```

- 두 개의 피연산자를 받는 연산자는 *이항(binary) 연산자* 라고 부릅니다. 마이너스 연산자는 아래와 같이 이항 연산자로 쓸 수도 있습니다.

  ```javascript
  let x = 1, y = 3;
  alert( y - x ); // 2, 이항 마이너스 연산자는 뺄셈을 해줍니다.
  ```

  위와 같이 부호를 반전해주는 단항 마이너스 연산자와 뺄셈에 쓰이는 이항 마이너스 연산자(뺄셈 연산자)는 기호는 같지만 수행하는 연산이 다릅니다. 두 연산을 구분하는 기준은 피연산자의 개수입니다.

## [수학](https://ko.javascript.info/operators#ref-96)

자바스크립트에서 지원하는 수학 연산자는 다음과 같습니다.

- 덧셈 연산자 `+`,
- 뺄셈 연산자 `-`,
- 곱셈 연산자 `*`,
- 나눗셈 연산자 `/`,
- 나머지 연산자 `%`,
- 거듭제곱 연산자 `**`

앞쪽 네 연산자는 설명이 필요 없겠지만, `%`와 `**`는 약간의 설명이 필요할 것 같네요.

## [나머지 연산자 %](https://ko.javascript.info/operators#ref-97)

나머지 연산자(remainder operator)는 `%` 기호로 나타내지만, 비율을 나타내는 퍼센트와 관련이 없습니다.

나머지 연산자를 사용한 표현식 `a % b`는 `a`를 `b`로 나눈 후 그 나머지([remainder](https://en.wikipedia.org/wiki/Remainder))를 정수로 반환해줍니다.

예시:

```javascript
alert( 5 % 2 ); // 5를 2로 나눈 후의 나머지인 1을 출력
alert( 8 % 3 ); // 8을 3으로 나눈 후의 나머지인 2를 출력
```

## [거듭제곱 연산자 **](https://ko.javascript.info/operators#ref-98)

거듭제곱 연산자(exponentiation operator)를 사용한 `a ** b`를 평가하면 `a`를 `b`번 곱한 값이 반환됩니다.

예시:

```javascript
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```

거듭제곱 연산자는 정수가 아닌 숫자에 대해서도 동작합니다. `1/2`을 사용하면 제곱근을 구할 수 있죠.

```javascript
alert( 4 ** (1/2) ); // 2 (1/2 거듭제곱은 제곱근)
alert( 8 ** (1/3) ); // 2 (1/3 거듭제곱은 세제곱근)
```

## [이항 연산자 '+'와 문자열 연결](https://ko.javascript.info/operators#ref-99)

이제 학교에서 배운 기본 산술 연산자를 넘어, 자바스크립트가 제공하는 특별한 연산자 기능에 대해 살펴봅시다.

덧셈 연산자 `+`는 대개 숫자를 더한 결과를 반환합니다.

그런데 이항 연산자 `+`의 피연산자로 문자열이 전달되면 덧셈 연산자는 덧셈이 아닌 문자열을 병합(연결)합니다.

```javascript
let s = "my" + "string";
alert(s); // mystring
```

따라서 이항 연산자 `+`를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다는 점에 주의해야 합니다.

예시:

```javascript
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

첫 번째 피연산자가 문자열인지, 두 번째 피연산자가 문자열인지는 중요하지 않습니다. 피연산자 중 어느 하나가 문자열이면 다른 하나도 문자열로 변환됩니다.

좀 더 복잡한 예시를 살펴봅시다.

```javascript
alert(2 + 2 + '1' ); // '221'이 아니라 '41'이 출력됩니다.
```

연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 이런 결과가 나왔습니다. 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열과의 병합이 일어납니다.

이처럼 이항 덧셈 연산자 `+`는 문자열 연결과 변환이라는 특별한 기능을 제공합니다. 다른 산술 연산자가 오직 숫자형의 피연산자만 다루고, 피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾸는 것과는 대조적입니다.

아래는 뺄셈 `-`과 나눗셈 `/` 연산자가 어떻게 문자형 피연산자를 다루는지를 보여줍니다.

```javascript
alert( 6 - '2' ); // 4, '2'를 숫자로 바꾼 후 연산이 진행됩니다.
alert( '6' / '2' ); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행됩니다.
```

## [단항 연산자 +와 숫자형으로의 변환](https://ko.javascript.info/operators#ref-100)

덧셈 연산자 `+`는 이항 연산자뿐만 아니라 단항 연산자로도 사용할 수 있습니다.

숫자에 단항 덧셈 연산자를 붙이면 이 연산자는 아무런 동작도 하지 않습니다. 그러나 피연산자가 숫자가 아닌 경우엔 숫자형으로의 변환이 일어납니다.

예시:

```javascript
// 숫자에는 아무런 영향을 미치지 않습니다.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
alert( +true ); // 1
alert( +"" );   // 0
```

단항 덧셈 연산자는 짧은 문법으로도 `Number(...)`와 동일한 일을 할 수 있게 해줍니다.

개발을 하다 보면 문자열을 숫자로 변환해야 하는 경우가 자주 생깁니다. HTML 폼(form) 필드에서 값을 가져왔는데 그 값이 문자형일 때 같이 말이죠. 실제로 폼에서 가지고 온 값은 대개 문자열 형태입니다.

이항 덧셈 연산자를 사용하면 아래와 같이 값이 문자열로 변해서 연결될 겁니다.

```javascript
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결합니다.
```

원하는 대로 값을 더해주려면, 단항 덧셈 연산자를 사용해 피연산자를 숫자형으로 변화시키면 됩니다.

```javascript
let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert( +apples + +oranges ); // 5

// `Number(...)`를 사용해서 같은 동작을 하는 코드를 작성할 수 있지만, 더 기네요.
// alert( Number(apples) + Number(oranges) ); // 5
```

위 식을 수학자가 본다면 불필요한 덧셈 기호에 대해 언급하며 식이 이상하다고 지적할 겁니다. 프로그래머라면 아니겠지만 말이죠. 위 식은 우리가 의도한 대로 단항 덧셈 연산자가 먼저 문자열을 숫자로 변환시키고, 이항 덧셈 연산자가 그 결과들을 더해주고 있습니다.

그런데 왜 이항 덧셈 연산자가 적용되기 전에 단항 덧셈 연산자가 먼저 적용될까요? 그 이유는 이제 학습하게 될 *연산자 우선순위* 때문입니다.

## [연산자 우선순위](https://ko.javascript.info/operators#ref-101)

하나의 표현식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 *우선순위(precedence)* 에 의해 결정됩니다.

`1 + 2 * 2`라는 식이 있을 때 곱셈이 먼저, 그 후에 덧셈이 일어난다는 것을 알고 계실 겁니다. 이런 개념이 연산자 우선순위입니다. 여기서 곱셈은 덧셈보다 *더 높은 우선순위*를 가지죠.

자바스크립트에서 정의한 연산자 우선순위가 마음에 들지 않는다면, 괄호를 사용하면 됩니다. 괄호는 모든 연산자보다 우선순위가 높기 때문에 자바스크립트에서 정의한 연산자 우선순위를 무력화시킵니다. 표현식 `(1 + 2) * 2`에서 괄호로 둘러싼 덧셈 연산자가 먼저 수행되는 것 같이 말이죠.

자바스크립트는 다양한 연산자를 제공하는데, 이 모든 연산자엔 우선순위가 매겨져 있습니다. 우선순위 숫자가 클수록 먼저 실행됩니다. 순위가 같으면 왼쪽부터 시작해서 오른쪽으로 연산이 수행됩니다.

아래는 [우선순위 테이블(precedence table)](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence)의 일부를 발췌한 표입니다. 순서를 기억할 필요는 없지만, 동일한 기호의 단항 연산자는 이항 연산자보다 우선순위가 더 높다는 것에 주목해 주시기 바랍니다.

| 순위 | 연산자 이름 | 기호 |
| :--- | :---------- | :--- |
| …    | …           | …    |
| 17   | 단항 덧셈   | `+`  |
| 17   | 단항 부정   | `-`  |
| 16   | 지수        | `**` |
| 15   | 곱셈        | `*`  |
| 15   | 나눗셈      | `/`  |
| 13   | 덧셈        | `+`  |
| 13   | 뺄셈        | `-`  |
| …    | …           | …    |
| 3    | 할당        | `=`  |
| …    | …           | …    |

'단항 덧셈 연산자’는 우선순위 `17`로, '(이항) 덧셈 연산자’의 우선순위 `13`보다 높습니다. 표현식 `"+apples + +oranges"`에서 단항 덧셈 연산자가 덧셈보다 먼저 수행되는 이유가 바로 이 때문입니다.

## [할당 연산자](https://ko.javascript.info/operators#ref-102)

무언가를 할당할 때 쓰이는 `=`도 연산자입니다. 이 연산자는 할당(assignment) 연산자라고 불리는데, 우선순위는 `3`으로 아주 낮습니다.

`x = 2 * 2 + 1`과 같은 표현식에서 계산이 먼저 이뤄지고, 그 결과가 `x`에 할당되는 이유가 바로 이 때문입니다.

```javascript
let x = 2 * 2 + 1;

alert( x ); // 5
```

### [값을 반환하는 할당 연산자](https://ko.javascript.info/operators#ref-103)

`=`는 연산자이기 때문에 흥미로운 함축성을 내포하고 있습니다.

자바스크립트에서 대부분의 연산자들은 값을 반환합니다. `+`와 `-`뿐만 아니라 `=` 역시 값을 반환하죠.

`x = value`을 호출하면 `value`가 `x`에 쓰여지고, 이에 더하여 *`value`가 반환됩니다*.

할당 연산자의 이런 특징을 이용한 복잡한 표현식을 살펴봅시다.

```javascript
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

위 예제에서 표현식 `(a = b + 1)`은 `a`에 값을 할당하고, 그 값인 `3`을 반환합니다. 그리고 반환 값은 이어지는 표현식에 사용됩니다.

괴상한 코드라고 느껴지겠지만, 여러 자바스크립트 라이브러리에서 이런 식으로 할당 연산자를 사용하고 있기 때문에 동작 원리를 이해할 수 있어야 합니다.

다만, 직접 코드를 작성할 땐 이런 방식을 사용하지 않기를 바랍니다. 이런 트릭을 사용하면 코드가 명확하지 않을 뿐만 아니라 가독성도 떨어지기 때문입니다.

### [할당 연산자 체이닝](https://ko.javascript.info/operators#ref-104)

할당 연산자는 아래와 같이 여러 개를 연결할 수도 있습니다(체이닝).

```javascript
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

이렇게 할당 연산자를 여러 개 연결한 경우, 평가는 우측부터 진행됩니다. 먼저 가장 우측의 `2 + 2`가 평가되고, 그 결과가 좌측의 `c`, `b`, `a`에 순차적으로 할당됩니다. 모든 변수가 단일 값을 공유하게 되죠.

그런데 되도록이면 연산자를 체이닝 하는것 보다 가독성을 위해 아래와 같이 줄을 나눠 코드를 작성하길 권유드립니다.

```javascript
c = 2 + 2;
b = c;
a = c;
```

이렇게 작성하면 읽기도 쉽고, 눈을 빠르게 움직이며 코드를 읽을 수 있습니다.

## [복합 할당 연산자](https://ko.javascript.info/operators#ref-105)

프로그램을 짜다 보면, 변수에 연산자를 적용하고 그 결과를 같은 변수에 저장해야 하는 경우가 종종 생깁니다.

아래와 같이 말이죠.

```javascript
let n = 2;
n = n + 5;
n = n * 2;
```

이때, `+=`와 `*=`연산자를 사용하면 짧은 문법으로 동일한 연산을 수행할 수 있습니다.

```javascript
let n = 2;
n += 5; // n은 7이 됩니다(n = n + 5와 동일).
n *= 2; // n은 14가 됩니다(n = n * 2와 동일).

alert( n ); // 14
```

이런 ‘복합 할당’ 연산자는 산술 연산자와 비트 연산자에도 적용할 수 있습니다. `/=`, `-=` 등의 연산자를 만들 수 있죠.

복합 할당 연산자의 우선순위는 할당 연산자와 동일합니다. 따라서 대부분 다른 연산자가 실행된 후에 복합 할당 연산자가 실행됩니다.

```javascript
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (*=의 우측이 먼저 평가되므로, 위 식은 n *= 8과 동일합니다.)
```

## [증가·감소 연산자](https://ko.javascript.info/operators#ref-106)

숫자를 하나 늘리거나 줄이는 것은 자주 사용되는 연산입니다.

자바스크립트에서는 이런 연산을 해주는 연산자를 제공합니다.

- **증가(increment) 연산자** `++`는 변수를 1 증가시킵니다.

  ```javascript
  let counter = 2;
  counter++;      // counter = counter + 1과 동일하게 동작합니다. 하지만 식은 더 짧습니다.
  alert( counter ); // 3
  ```

- **감소(decrement) 연산자** `--`는 변수를 1 감소시킵니다.

  ```javascript
  let counter = 2;
  counter--;      // counter = counter - 1과 동일하게 동작합니다. 하지만 식은 더 짧습니다.
  alert( counter ); // 1
  ```

**중요:**

증가·감소 연산자는 변수에만 쓸 수 있습니다. `5++`와 같이 값에 사용하려고 하면 에러가 발생합니다.

`++`와`--` 연산자는 변수 앞이나 뒤에 올 수 있습니다.

- `counter++`와 같이 피연산자 뒤에 올 때는, '후위형(postfix form)'이라고 부릅니다.
- `++counter`와 같이 피연산자 앞에 올 때는, '전위형(prefix form)'이라고 부릅니다.

후위형과 전위형은 피연산자인 `counter`를 `1`만큼 증가시켜 준다는 점에서 동일한 일을 합니다.

두 형의 차이는 `++/--`의 반환 값을 사용할 때 드러납니다.

자, 다시 상기해 보도록 합시다. 이미 배운 바와 같이 모든 연산자는 값을 반환합니다. 증가·감소 연산자도 마찬가지입니다. 전위형은 증가·감소 후의 새로운 값을 반환하는 반면, 후위형은 증가·감소 전의 기존 값을 반환합니다.

아래 예시를 통해 차이점을 직접 살펴보도록 합시다.

```javascript
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
```

`(*)`로 표시한 줄의 *전위형* `++counter`는 `counter`를 증가시키고 새로운 값 `2`를 반환합니다. 따라서 `alert`는 `2`를 표시합니다.

이제 후위형을 살펴봅시다.

```javascript
let counter = 1;
let a = counter++; // (*) ++counter를 counter++로 바꿈

alert(a); // 1
```

`(*)`로 표시한 줄의 *후위형* `counter++`는 `counter`를 증가시키긴 하지만, 증가 전의 *기존* 값을 반환합니다. 따라서 `alert`는 `1`을 표시합니다.

증가, 감소 연산자에 대한 내용을 정리하면 아래와 같습니다.

- 반환 값을 사용하지 않는 경우라면, 전위형과 후위형엔 차이가 없습니다.

  ```javascript
  let counter = 0;
  counter++;
  ++counter;
  alert( counter ); // 2, 위 두 라인은 동일한 연산을 수행합니다.
  ```

- 값을 증가시키고 난 후, 증가한 값을 바로 사용하려면 전위형 증가 연산자를 사용하면 됩니다.

  ```javascript
  let counter = 0;
  alert( ++counter ); // 1
  ```

- 값을 증가시키지만, 증가 전의 기존값을 사용하려면 후위형 증가 연산자를 사용하면 됩니다.

  ```javascript
  let counter = 0;
  alert( counter++ ); // 0
  ```

**다른 연산자 사이의 증가·감소 연산자**

`++/--` 연산자를 표현식 중간에 사용하는 것도 가능합니다. 이때, 증가·감소 연산자의 우선순위는 다른 대부분의 산술 연산자보다 높기 때문에, 평가가 먼저 이뤄집니다.

예시:

```javascript
let counter = 1;
alert( 2 * ++counter ); // 4
```

위 예시를 아래와 비교해 봅시다.

```javascript
let counter = 1;
alert( 2 * counter++ ); // counter++는 '기존'값을 반환하기 때문에 2가 출력됩니다.
```

이렇게 코드를 작성하는 게 기술적으로 문제가 있는 것은 아니지만, 한 줄에서 여러 가지 일을 동시에 하고 있기 때문에 코드의 가독성이 떨어집니다.

코드를 읽을 때 눈을 ‘수직으로’ 빠르게 움직이다 보면 `counter++`와 같은 것을 놓치기 쉽습니다. 변수가 증가했다는 것을 놓칠 수 있죠.

'코드 한 줄엔, 특정 동작 하나’에 관련된 내용만 작성하는 게 좋습니다. 아래와 같이 말이죠.

```javascript
let counter = 1;
alert( 2 * counter );
counter++;
```

## [비트 연산자](https://ko.javascript.info/operators#ref-107)

비트 연산자(bitwise operator)는 인수를 32비트 정수로 변환하여 이진 연산을 수행합니다.

이런 비트 조작 관련 연산자는 자바스크립트뿐만 아니라 대부분의 프로그래밍 언어에서 지원합니다.

아래는 비트 연산 시 쓰이는 연산자 목록입니다.

- 비트 AND ( `&` )
- 비트 OR ( `|` )
- 비트 XOR ( `^` )
- 비트 NOT ( `~` )
- 왼쪽 시프트(LEFT SHIFT) ( `<<` )
- 오른쪽 시프트(RIGHT SHIFT) ( `>>` )
- 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( `>>>` )

비트 연산자는 저수준(2진 표현)에서 숫자를 다뤄야 할 때 쓰이므로 흔하게 쓰이진 않습니다. 웹 개발 시엔 이런 일이 자주 일어나지 않기 때문에 비트 연산자를 만날 일은 거의 없죠. 그렇긴 해도 암호를 다뤄야 할 땐 비트 연산자가 유용하기 때문에 때가 되면 MDN의 [비트 연산자](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) 문서를 보시는 걸 추천합니다.

## [쉼표 연산자](https://ko.javascript.info/operators#ref-108)

쉼표 연산자(comma operator) `,`는 좀처럼 보기 힘들고, 특이한 연산자 중 하나입니다. 코드를 짧게 쓰려는 의도로 가끔 사용됩니다. 이런 코드를 만났을 때, 어떤 연산 결과가 도출되는지 알아야 하므로 쉼표 연산자에 대해 알아보도록 합시다.

쉼표 연산자 `,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해줍니다. 이때 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환되는 점에 유의해야 합니다.

예시:

```javascript
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (3 + 4의 결과)
```

위 예시에서 첫 번째 표현식 `1 + 2`은 평가가 되지만 그 결과는 버려집니다. `3 + 4`만 평가되어 `a`에 할당되죠.

**쉼표의 우선순위는 매우 낮습니다.**

쉼표 연산자의 연산자 우선순위는 매우 낮습니다. 할당 연산자 `=` 보다 더 낮죠. 따라서 위 예시에선 괄호가 중요한 역할을 합니다.

괄호가 없으면 `a = 1 + 2, 3 + 4`에서 `+`가 먼저 수행되어 `a = 3, 7`이 됩니다. 할당 연산자 `=`는 쉼표 연산자보다 우선순위가 높기 때문에 `a = 3`이 먼저 실행되고, 나머지(`7`)는 무시되죠. `(a = 1 + 2), 3 + 4`를 연산한 것처럼 될 겁니다.

이렇게 마지막 표현식을 제외한 모든 것을 버리는 연산자는 어디서 사용되는 걸까요?

여러 동작을 하나의 줄에서 처리하려는 복잡한 구조에서 이를 사용합니다.

아래와 같이 말이죠.

```javascript
// 한 줄에서 세 개의 연산이 수행됨
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

쉼표 연산자를 사용한 트릭은 여러 자바스크립트 프레임워크에서 볼 수 있습니다. 이 연산자의 사용 빈도가 높지 않지만, 언급하고 넘어가는 이유이죠. 쉼표 연산자는 코드 가독성에 도움이 되지 않습니다. 따라서 곰곰이 생각해 본 후, 진짜 필요한 경우에만 사용하시길 바랍니다.

# 2.9

# 비교 연산자

우리는 수학 시간에 아래와 같은 다양한 비교 연산자에 대해 학습한 바 있습니다.

자바스크립트에서 기본 수학 연산은 아래와 같은 문법을 사용해 표현할 수 있습니다.

- 보다 큼·작음: `a > b`, `a < b`
- 보다 크거나·작거나 같음: `a >= b`, `a <= b`
- 같음(동등): `a == b`. 등호 `=`가 두 개 연달아 오는 것에 유의하세요. `a = b`와 같이 등호가 하나일 때는 할당을 의미합니다.
- 같지 않음(부등): 같지 않음을 나타내는 수학 기호 `≠`는 자바스크립트에선 `a != b`로 나타냅니다. 할당연산자 `=` 앞에 느낌표 `!`를 붙여서 표시합니다.

이번 글에선 비교 시 일어나는 기이한 현상을 포함하여 다양한 자료형을 대상으로 자바스크립트가 어떻게 비교를 하는지에 대해 다룰 예정입니다.

글 말미에는 자바스크립트에서만 일어나는 ‘기이한’ 현상을 어떻게 예방할 수 있는지에 대해서 언급해두었습니다.

## [불린형 반환](https://ko.javascript.info/comparison#ref-968)

다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환합니다. 반환 값은 불린형입니다.

- `true`가 반환되면, ‘긍정’, ‘참’, '사실’을 의미합니다.
- `false`가 반환되면, ‘부정’, ‘거짓’, '사실이 아님’을 의미합니다.

예시:

```javascript
alert( 2 > 1 );  // true
alert( 2 == 1 ); // false
alert( 2 != 1 ); // true
```

반환된 불린값은 다른 여타 값처럼 변수에 할당 할 수 있습니다.

```javascript
let result = 5 > 4; // 비교 결과를 변수에 할당
alert( result ); // true
```

## [문자열 비교](https://ko.javascript.info/comparison#ref-969)

자바스크립트는 ‘사전’ 순으로 문자열을 비교합니다. '사전편집(lexicographical)'순이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단됩니다.

실제 단어를 사전에 실을 때 단어를 구성하는 문자 하나하나를 비교하여 등재 순서를 정하는 것과 같이 자바스크립트도 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교합니다.

예시:

```javascript
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

문자열 비교 시 적용되는 알고리즘은 다음과 같습니다.

1. 두 문자열의 첫 글자를 비교합니다.
2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료합니다.
3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교합니다.
4. 글자 간 비교가 끝날 때까지 이 과정을 반복합니다.
5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 냅니다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 냅니다.

예시의 `'Z' > 'A'`는 위 알고리즘의 첫 번째 단계에서 비교 결과가 도출됩니다. 반면, 문자열 `'Glow'`와 `'Glee'`는 복수의 문자로 이루어진 문자열이기 때문에, 아래와 같은 순서로 문자열 비교가 이뤄집니다.

1. `G`는 `G`와 같습니다.
2. `l`은 `l`과 같습니다.
3. `o`는 `e`보다 크기 때문에 여기서 비교가 종료되고, `o`가 있는 첫 번째 문자열 `'Glow'`가 더 크다는 결론이 도출됩니다.

**정확히는 사전 순이 아니라 유니코드 순입니다.**

자바스크립트의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만, 완전히 같진 않습니다.

차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것입니다. 대문자 `'A'`와 소문자 `'a'`를 비교했을 때 소문자 `'a'`가 더 큽니다. 자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이죠. 이와 관련한 자세한 내용은 [문자열](https://ko.javascript.info/string) 챕터에서 다루도록 하겠습니다.

## [다른 형을 가진 값 간의 비교](https://ko.javascript.info/comparison#ref-970)

비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꿉니다.

예시:

```javascript
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
```

불린값의 경우 `true`는 `1`, `false`는 `0`으로 변환된 후 비교가 이뤄집니다.

예시:

```javascript
alert( true == 1 ); // true
alert( false == 0 ); // true
```

**흥미로운 상황**

동시에 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있습니다.

- 동등 비교(`==`) 시 true를 반환함
- 논리 평가 시 값 하나는 `true`, 다른 값 하나는 `false`를 반환함

예시:

```javascript
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

두 값(a와 b)을 비교하면 참이 반환되는데, 값을 논리 평가한 후 비교하면 하나는 참, 하나는 거짓이 반환된다는 점에 고개를 갸우뚱할 수도 있습니다. 그런데 자바스크립트 관점에선 이런 결과가 아주 자연스럽습니다. 동등 비교 연산자 `==`는 (예시에서 문자열 `"0"`을 숫자 `0`으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문입니다.

## [일치 연산자](https://ko.javascript.info/comparison#ref-971)

동등 연산자(equality operator) `==`은 `0`과 `false`를 구별하지 못합니다.

```javascript
alert( 0 == false ); // true
```

피연산자가 빈 문자열일 때도 같은 문제가 발생하죠.

```javascript
alert( '' == false ); // true
```

이런 문제는 동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생합니다. 빈 문자열과 `false`는 숫자형으로 변환하면 0이 되죠.

그렇다면 `0`과 `false`는 어떻게 구별할 수 있을까요?

**일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값을 비교할 수 있습니다.**

일치 연산자는 엄격한(strict) 동등 연산자입니다. 자료형의 동등 여부까지 검사하기 때문에 피연산자 `a`와 `b`의 형이 다를 경우 `a === b`는 즉시 `false`를 반환합니다.

예시:

```javascript
alert( 0 === false ); // false, 피연산자의 형이 다르기 때문입니다.
```

일치 연산자 `===`가 동등 연산자 `==`의 엄격한 버전인 것처럼 ‘불일치’ 연산자 `!==`는 부등 연산자 `!=`의 엄격한 버전입니다.

일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여줍니다.

## [null이나 undefined와 비교하기](https://ko.javascript.info/comparison#ref-972)

`null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생합니다. 일단 몇 가지 규칙을 먼저 살펴본 후, 어떤 예상치 않은 일들이 일어나는지 구체적인 예시를 통해 살펴보도록 하겠습니다.

- 일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교

  두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환됩니다.`alert( null === undefined ); // false`

- 동등 연산자 `==`를 사용하여 `null`과 `undefined`를 비교

  동등 연산자를 사용해 `null`과 `undefined`를 비교하면 특별한 규칙이 적용돼 `true`가 반환됩니다. 동등 연산자는 `null`과 `undefined`를 '각별한 커플’처럼 취급합니다. 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못합니다.`alert( null == undefined ); // true`

- 산술 연산자나 기타 비교 연산자 `<`, `>`, `<=`, `>=`를 사용하여 `null`과 `undefined`를 비교

  `null`과 `undefined`는 숫자형으로 변환됩니다. `null`은 `0`, `undefined`는 `NaN`으로 변합니다.

이제 위에서 살펴본 세 가지 규칙들이 어떤 흥미로운 에지 케이스(edge case)를 만들어내는지 알아봅시다. 이후, 어떻게 하면 에지 케이스가 만들어내는 함정에 빠지지 않을 수 있을지에 대해 알아보겠습니다.

### [null vs 0](https://ko.javascript.info/comparison#ref-973)

`null`과 0을 비교해 봅시다.

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

위 비교 결과는 논리에 맞지 않아 보입니다. (3)에서 `null`은 `0`보다 크거나 같다고 했기 때문에, (1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환하고 있네요.

이런 결과가 나타나는 이유는 동등 연산자 `==`와 기타 비교 연산자 `<`, `>`, `<=`, `>=`의 동작 방식이 다르기 때문입니다. (1)에서 `null > 0`이 거짓을, (3)에서 `null >= 0`이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) `null`이 숫자형으로 변환돼 `0`이 되기 때문입니다.

그런데 동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않습니다. `undefined`와 `null`을 비교하는 경우에만 `true`를 반환하고, 그 이외의 경우(`null`이나 `undefined`를 다른 값과 비교할 때)는 무조건 `false`를 반환합니다. 이런 이유 때문에 (2)는 거짓을 반환합니다.

### [비교가 불가능한 undefined](https://ko.javascript.info/comparison#ref-974)

`undefined`를 다른 값과 비교해서는 안 됩니다.

```javascript
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

위 예시를 보면 `undefined`는 0을 매우 싫어하는 것처럼 보입니다. 항상 `false`를 반환하고 있네요.

이런 결과는 아래와 같은 이유 때문에 발생합니다.

- `(1)`과`(2)`에선 `undefined`가 `NaN`으로 변환되는데(숫자형으로의 변환), `NaN`이 피연산자인 경우 비교 연산자는 항상 `false`를 반환합니다.
- `undefined`는 `null`이나 `undefined`와 같고, 그 이외의 값과는 같지 않기 때문에 `(3)`은 `false`를 반환합니다.

### [함정 피하기](https://ko.javascript.info/comparison#ref-975)

위와 같은 에지 케이스를 왜 살펴보았을까요? 이런 예외적인 경우를 꼭 기억해 놓고 있어야만 할까요? 그렇지는 않습니다. 개발을 하다 보면 자연스레 이런 경우를 만나고 점차 익숙해지기 때문에 지금 당장 암기해야 할 필요는 없습니다. 하지만 아래와 같은 방법을 사용해 이런 예외 상황을 미리 예방할 수 있다는 점은 알아두시길 바랍니다.

- 일치 연산자 `===`를 제외한 비교 연산자의 피연산자에 `undefined`나 `null`이 오지 않도록 특별히 주의하시기 바랍니다.
- 또한, `undefined`나 `null`이 될 가능성이 있는 변수가 `<`, `>`, `<=`, `>=`의 피연산자가 되지 않도록 주의하시기 바랍니다. 명확한 의도를 갖고 있지 않은 이상 말이죠. 만약 변수가 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하시기 바랍니다.

## [요약](https://ko.javascript.info/comparison#ref-976)

- 비교 연산자는 불린값을 반환합니다.
- 문자열은 문자 단위로 비교되는데, 이때 비교 기준은 ‘사전’ 순입니다.
- 서로 다른 타입의 값을 비교할 땐 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행됩니다(일치 연산자는 제외).
- `null`과 `undefined`는 동등 비교(`==`) 시 서로 같지만 다른 값과는 같지 않습니다.
- `null`이나 `undefined`가 될 확률이 있는 변수가 `>` 또는 `<`의 피연산자로 올 때는 주의를 기울이시기 바랍니다. `null`, `undefined` 여부를 확인하는 코드를 따로 추가하는 습관을 들이길 권유합니다.

# 2.10

# if와 '?'를 사용한 조건 처리

조건에 따라 다른 행동을 취해야 할 때가 있습니다.

이럴 땐, `if`문과 ‘물음표’ 연산자라고도 불리는 조건부 연산자 `?`를 사용하면 됩니다.

## ['if’문](https://ko.javascript.info/ifelse#ref-113)

`if(...)`문은 괄호 안에 들어가는 조건을 평가하는데, 그 결과가 `true`이면 코드 블록이 실행됩니다.

예시:

```javascript
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year == 2015) alert( '정답입니다!' );
```

위 예시에선 조건(`year == 2015`)이 간단한 경우만 다뤘는데, 조건문은 더 복잡할 수도 있습니다.

조건이 `true`일 때 복수의 문을 실행하고 싶다면 중괄호로 코드 블록을 감싸야 합니다.

```javascript
if (year == 2015) {
  alert( "정답입니다!" );
  alert( "아주 똑똑하시네요!" );
}
```

`if`문을 쓸 때는 조건이 참일 경우 실행되는 구문이 단 한 줄이더라도 중괄호 `{}`를 사용해 코드를 블록으로 감싸는 것을 추천해 드립니다. 이렇게 하면 코드 가독성이 증가합니다.

## [불린형으로의 변환](https://ko.javascript.info/ifelse#ref-114)

`if (…)` 문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환합니다.

[형 변환](https://ko.javascript.info/type-conversions) 챕터에서 배운 형 변환 규칙을 잠시 상기해 봅시다.

- 숫자 `0`, 빈 문자열`""`, `null`, `undefined`, `NaN`은 불린형으로 변환 시 모두 `false`가 됩니다. 이런 값들은 ‘falsy(거짓 같은)’ 값이라고 부릅니다.
- 이 외의 값은 불린형으로 변환시 `true`가 되므로 ‘truthy(참 같은)’ 값이라고 부릅니다.

이 규칙에 따르면 아래 예시의 코드 블록은 절대 실행되지 않습니다.

```javascript
if (0) { // 0은 falsy입니다.
  ...
}
```

아래 예시의 코드 블록은 항상 실행됩니다.

```javascript
if (1) { // 1은 truthy입니다.
  ...
}
```

아래와 같이 평가를 통해 확정된 불린값을 `if`문에 전달할 수도 있습니다.

```javascript
let cond = (year == 2015); // 동등 비교를 통해 true/false 여부를 결정합니다.

if (cond) {
  ...
}
```

## ['else’절](https://ko.javascript.info/ifelse#ref-115)

`if`문엔 `else` 절을 붙일 수 있습니다. `else` 뒤에 이어지는 코드 블록은 조건이 거짓일 때 실행됩니다.

예시:

```javascript
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year == 2015) {
  alert( '정답입니다!' );
} else {
  alert( '오답입니다!' ); // 2015 이외의 값을 입력한 경우
}
```

## ['else if’로 복수 조건 처리하기](https://ko.javascript.info/ifelse#ref-116)

유사하지만 약간씩 차이가 있는 조건 여러 개를 처리해야 할 때가 있습니다. 이때 `else if`를 사용할 수 있습니다.

예시:

```javascript
let year = prompt('ECMAScript-2015 명세는 몇 년도에 출판되었을까요?', '');

if (year < 2015) {
  alert( '숫자를 좀 더 올려보세요.' );
} else if (year > 2015) {
  alert( '숫자를 좀 더 내려보세요.' );
} else {
  alert( '정답입니다!' );
}
```

위 예시에서, 자바스크립트는 조건 `year < 2015`를 먼저 확인합니다. 이 조건이 거짓이라면 다음 조건 `year > 2015`를 확인합니다. 이 조건 또한 거짓이라면 `else` 절 내의 `alert`를 실행합니다.

`else if` 블록을 더 많이 붙이는 것도 가능합니다. 마지막에 붙는 `else`는 필수가 아닌 선택 사항입니다.

## [조건부 연산자 ‘?’](https://ko.javascript.info/ifelse#ref-117)

조건에 따라 다른 값을 변수에 할당해줘야 할 때가 있습니다.

예시:

```javascript
let accessAllowed;
let age = prompt('나이를 입력해 주세요.', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
```

'물음표(question mark) 연산자’라고도 불리는 '조건부(conditional) 연산자’를 사용하면 위 예시를 더 짧고 간결하게 변형할 수 있습니다.

조건부 연산자는 물음표`?`로 표시합니다. 피연산자가 세 개이기 때문에 조건부 연산자를 '삼항(ternary) 연산자’라고 부르는 사람도 있습니다. 참고로, 자바스크립트에서 피연산자를 3개나 받는 연산자는 조건부 연산자가 유일합니다.

문법:

```javascript
let result = condition ? value1 : value2;
```

평가 대상인 `condition`이 truthy라면 `value1`이, 그렇지 않으면 `value2`가 반환됩니다.

예시:

```javascript
let accessAllowed = (age > 18) ? true : false;
```

`age > 18` 주위의 괄호는 생략 가능합니다. 물음표 연산자는 우선순위가 낮으므로 비교 연산자 `>`가 실행되고 난 뒤에 실행됩니다.

아래 예시는 위 예시와 동일하게 동작합니다.

```javascript
// 연산자 우선순위 규칙에 따라, 비교 연산 'age > 18'이 먼저 실행됩니다.
// (조건문을 괄호로 감쌀 필요가 없습니다.)
let accessAllowed = age > 18 ? true : false;
```

괄호가 있으나 없으나 차이는 없지만, 코드의 가독성 향상을 위해 괄호를 사용할 것을 권유합니다.

**주의:**

비교 연산자 자체가 `true`나 `false`를 반환하기 때문에 위 예시에서 물음표 연산자를 사용하지 않아도 됩니다.

```javascript
// 동일하게 동작함
let accessAllowed = age > 18;
```

## [다중 ‘?’](https://ko.javascript.info/ifelse#ref-118)

물음표 연산자`?`를 여러 개 연결하면 복수의 조건을 처리할 수 있습니다.

예시:

```javascript
let age = prompt('나이를 입력해주세요.', 18);

let message = (age < 3) ? '아기야 안녕?' :
  (age < 18) ? '안녕!' :
  (age < 100) ? '환영합니다!' :
  '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';

alert( message );
```

물음표 연산자를 이런 방식으로 쓰는 걸 처음 본 분이라면 이 코드가 어떻게 동작하는지 파악하기 힘들 수 있습니다. 그러나 주의를 집중하고 보면, 단순히 여러 조건을 나열한 코드임에 불과하다는 것을 알 수 있습니다.

1. 첫 번째 물음표에선 조건문 `age < 3`을 검사합니다.
2. 그 결과가 참이면 `'아기야 안녕?'`를 반환합니다. 그렇지 않다면 첫 번째 콜론 `":"`에 이어지는 조건문 `age < 18`을 검사합니다.
3. 그 결과가 참이면 `'안녕!'`를 반환합니다. 그렇지 않다면 다음 콜론 `":"`에 이어지는 조건문 `age < 100`을 검사합니다.
4. 그 결과가 참이면 `'환영합니다!'`를 반환합니다. 그렇지 않다면 마지막 콜론 `":"` 이후의 표현식인 `'나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!'`를 반환합니다.

`if..else`를 사용하면 위 예시를 아래와 같이 변형할 수 있습니다.

```javascript
if (age < 3) {
  message = '아기야 안녕?';
} else if (age < 18) {
  message = '안녕!';
} else if (age < 100) {
  message = '환영합니다!';
} else {
  message = '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';
}
```

## [부적절한 ‘?’](https://ko.javascript.info/ifelse#ref-119)

물음표`?`를 `if` 대용으로 쓰는 경우가 종종 있습니다.

```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

(company == 'Netscape') ?
   alert('정답입니다!') : alert('오답입니다!');
```

조건 `company == 'Netscape'`의 검사 결과에 따라 `?` 뒤에 이어지는 첫 번째 혹은 두 번째 표현식이 실행되어 얼럿 창이 뜹니다.

위 예시에선 평가 결과를 변수에 할당하지 않고, 결과에 따라 실행되는 표현식이 달라지도록 하였습니다.

그런데 **이런 식으로 물음표 연산자를 사용하는 것은 좋지 않습니다.**

개발자 입장에선 `if`문을 사용할 때 보다 코드 길이가 짧아진다는 점 때문에 물음표`?`를 `if` 대용으로 쓰는 게 매력적일 순 있습니다. 하지만 이렇게 코드를 작성하면 가독성이 떨어집니다.

아래는 `if`를 사용해 변형한 코드입니다. 어느 코드가 더 읽기 쉬운지 직접 비교해 보시기 바랍니다.

```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```

코드를 읽을 때 우리의 눈은 수직으로 움직입니다. 수평으로 길게 늘어진 코드보단 여러 줄로 나뉘어 작성된 코드 블록이 더 읽기 쉽죠.

물음표 연산자`?`는 조건에 따라 반환 값을 달리하려는 목적으로 만들어졌습니다. 이런 목적에 부합하는 곳에 물음표를 사용하시길 바랍니다. 여러 분기를 만들어 처리할 때는 `if`를 사용하세요.