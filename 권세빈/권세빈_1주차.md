# JS-Tutorial

## script 태그

> `<script>` 태그를 이용하면 자바스크립트 프로그램을 HTML 문서 대부분의 위치에 삽입할 수 있다.

```html
<!DOCTYPE HTML>
<html>

<body>

  <p>스크립트 전</p>

  <script>
    alert( 'Hello, world!' );
  </script>

  <p>스크립트 후</p>

</body>

</html>
```

`<script>` 태그엔 자바스크립트 코드가 들어간다.

<br>

### 모던 마크업

> `script` 태그엔 몇 가지 **속성(attribute)** 이 있다.
>
> 요즘엔 잘 사용하지 않지만, 오래된 코드에서 종종 볼 수 있다.

- **type 속성:** `<script type=…>`
  - HTML4에선 스크립트에 `type`을 명시하는 것이 필수였다. 이제는 필수가 아니다. 이제 이 속성은 **자바스크립트 모듈에 사용**할 수 있다.

- **language 속성:** `<script language=…>`
  - 이 속성은 현재 사용하고 있는 스크립트 언어를 나타낸다. 지금은 자바스크립트가 기본 언어이므로 속성의 의미가 퇴색되었으므로 **더는 사용할 필요가 없다.**

<br>

### 외부 스크립트

> 자바스크립트 코드의 양이 많은 경우엔, 파일로 소분하여 저장할 수 있다.

이렇게 분해해 놓은 각 파일은 `src` 속성을 사용해 HTML에 삽입한다.

```html
<script src="/path/to/script.js"></script>
```

- `/path/to/script.js`는 사이트의 루트에서부터 파일이 위치한 **절대 경로**를 나타낸다. 현재 페이지에서의 **상대 경로를 사용하는 것도 가능**하다. 
  - 같은 폴더 내에 있는 파일인 `"script.js"`를 `src="script.js"`로 참조 가능

아래와 같이 URL 전체를 속성으로 사용할 수 있다.

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
```

복수의 스크립트를 HTML에 삽입하고 싶다면 스크립트 태그를 여러 개 사용하면 된다.

```html
<script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
```

<br>

#### 주의

- HTML 안에 직접 스크립트를 작성하는 방식은 대개 **스크립트가 아주 간단할 때만 사용**

- 스크립트가 길어지면 **별개의 분리된 파일로 만들어 저장하는 것이 좋다.**
  - 스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 [캐시(cache)](https://en.wikipedia.org/wiki/Web_cache)에 저장하기 때문에, 성능상의 이점이 있다.

> 여러 페이지에서 동일한 스크립트를 사용하는 경우, 브라우저는 페이지가 바뀔 때마다 스크립트를 새로 다운받지 않고 캐시로부터 스크립트를 가져와 사용한다. 이를 통해 트래픽이 절약되고 웹 페이지의 실제 속도가 빨라진다.



#### `src` 속성이 있으면 태그 내부의 코드는 무시된다.

> `<script>` 태그는 `src` 속성과 내부 코드를 **동시에 가지지 못합니다.**

다음 코드는 실행되지 않는다.

```html
<script src="file.js">
  alert(1); // src 속성이 사용되었으므로 이 코드는 무시됩니다.
</script>
```

따라서 `<script src="…">`로 외부 파일을 연결할지 아니면 `<script>` 태그 내에 코드를 작성할지를 선택해야 한다.

위의 예시는 스크립트 두 개로 분리하면 정상적으로 실행된다.

```html
<script src="file.js"></script>
<script>
  alert(1);
</script>
```

<br>

# 코드구조

## 세미콜론

세미콜론은 생략할 수 있습니다. 하지만 줄 바꿈으로 문을 나눴더라도, **문 사이엔 세미콜론을 넣는 것이 좋다.**

<br>

## 주석

- `//` : 한 줄 짜리 주석
  - `Cmd+/`
- `/*` `*/` : 여러 줄 주석
  - `Cmd+Shift+/ `

> 중첩 주석은 지원하지 않는다.

<br>

# 엄격 모드

> 새롭게 제정된 ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있다. 
>
> 그래서 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었다. 
>
> 대신 `use strict`라는 특별한 지시자를 사용해 **엄격 모드(strict mode)를 활성화 했을 때만 이 변경사항이 활성화되게 해놓았다.**

## use strict

지시자 `"use strict"`, 혹은 `'use strict'`가 **스크립트 최상단에 오면 스크립트 전체가 “모던한” 방식으로 동작한다.**

```javascript
"use strict";

// 이 코드는 모던한 방식으로 실행된다.
...
```

- `"use strict"`는 대개 스크립트 전체에 적용되지만 스크립트 최상단이 아닌 함수 본문 맨 앞에 올 수도 있다. 이렇게 하면 **오직 해당 함수만 엄격 모드로 실행된다.** 

<br>

### "use strict"는 반드시 최상단에 위치시켜야 한다.

>  그렇지 않으면 엄격 모드가 활성화되지 않을 수도 있다.

다음 코드에서는 엄격 모드가 활성화되지 않는다.

```javascript
alert("some code");
// 하단에 위치한 "use strict"는 스크립트 상단에 위치하지 않으므로 무시된다.

"use strict";

// 엄격 모드가 활성화되지 않는다.
```

`"use strict"`의 위에는 주석만 사용할 수 있다.

### "use strict"를 취소할 방법은 없다.

> 자바스크립트 엔진을 이전 방식으로 되돌리는 `"no use strict"`같은 지시자는 존재하지 않는다.

일단 엄격 모드가 적용되면 돌이킬 방법은 없다.

<br>

## 브라우저 콘솔

>  개발한 기능을 테스트하기 위해 **브라우저 콘솔**을 사용하는 경우, **기본적으로 `use strict`이 적용되어있지 않는다는 점에 주의**해야 한다.

`use strict`에 영향을 받는 경우라면 개발자는 기대하지 않았던 결과를 얻을 수 있기 때문이다.

<br>

### 'use strict’를 꼭 사용해야 하나

> 코드를 **클래스와 모듈** 을 사용해 구성한다면 `"use strict"`를 생략해도 된다.

<br>

# 변수와 상수

> 자바스크립트 애플리케이션은 사용자나 서버로부터 입력받은 정보를 처리하는 방식으로 동작한다. 변수는 이러한 정보를 저장하는 용도로 사용된다.

1. 온라인 쇼핑몰 – 판매 중인 상품이나 장바구니 등의 정보
2. 채팅 애플리케이션 – 사용자 정보, 메시지 등의 정보

<br>

## 변수

- 자바스크립트에선 `let` 키워드를 사용해 변수를 생성한다.

```javascript
let message;
message = 'Hello!';

let message = 'Hello!'; 

// 한 줄에 여러 변수를 선언하는 것도 가능
let user = 'John', age = 25, message = 'Hello';

// 하지만 가독성을 위해 따로 작성하는 것을 추천
let user = 'John';
let age = 25;
let message = 'Hello';

//---

let Hello = 'Hello world!';

let message;

// Hello의 'Hello world' 값을 message에 복사
message = Hello;

// 이제 두 변수는 같은 데이터를 가진다.
alert(Hello); // Hello world!
alert(message); // Hello world!
```

<br>

### `let` 대신 `var`

```javascript
var message = 'Hello';
```

> `var`는 `let`과 거의 동일하게 동작한다. `var`도 `let`처럼 변수를 선언하는 데 쓰지만 `var`는 ‘오래된’ 방식이다.

<br>

### 🚨 **변수를 두 번 선언하면 에러가 발생한다.**

> 변수는 한 번만 선언해야 한다. 같은 변수를 여러 번 선언하면 에러가 발생한다.

```javascript
let message = "This";

// 'let'을 반복하면 에러가 발생
let message = "That"; 
// SyntaxError: 'message' has already been declared
```

- 따라서 **변수는 딱 한 번만 선언**하고, 선언한 변수를 참조할 때는 **`let` 없이 변수명만 사용해 참조**해야 한다.

#### 함수형 언어

> 함수형(functional) 프로그래밍 언어는 변숫값 변경을 금지한다. 스칼라(Scala)와 얼랭(Erlang)은 대표적인 함수형 언어이다.

- 한번 선언된 변수에 다른 값을 저장하고 싶으면 새 변수를 선언해야만 한다.
- 함수형 언어는 중대한 개발에 적합한 언어이다. 병렬 계산에 장점으로 작용한다.

<br>

### 변수 명명 규칙

1. 변수명에는 오직 문자와 숫자, 그리고 기호 `$`와 `_`만 들어갈 수 있다.
2. 첫 글자는 숫자가 될 수 없다.
3. 대/소문자 구별된다.
4. 예약어는 변수명으로 사용할 수 없다.

<br>

## 상수

- 변화하지 않는 변수를 선언할 땐, `let` 대신 `const`를 사용한다.

```javascript
const myBirthday = '18.04.1982';
```

- 상수는 **재할당할 수 없으므로** 상수를 변경하려고 하면 에러가 발생한다. 값이 변경되는 것을 방지할 수 있다.

```javascript
const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; 
// error, can't reassign the constant!
```

<br>

### 대문자 상수

> ‘하드 코딩한’ 값의 별칭을 만들 때 사용하면 된다. 코드가 실행되기 전에 이미 그 값을 알고 있는 상수

```javascript
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// 색상을 고르고 싶을 때 별칭을 사용할 수 있게 된다.
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

```javascript
const pageLoadTime = /* 웹페이지를 로드하는데 걸린 시간 */;
```

- 런타임 과정에서 계산되지만 최초 할당 이후 값이 변하지 않는 상수는 일반적인 방식으로 상수를 명명한다.

<br>

## 바람직한 변수명

- `userName` 이나 `shoppingCart`처럼 사람이 읽을 수 있는 이름을 사용하라.
- 무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 `a`, `b`, `c`와 같은 짧은 이름은 피하라.
- 최대한 서술적이고 간결하게 명명하라. `data`와 `value`는 나쁜 이름의 예시다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용하자.
- 자신만의 규칙이나 소속된 팀의 규칙을 따르라. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 `currentVisitor`나 `newManInTown`이 아닌 `currentUser`나 `newUser`라는 이름으로 지어야 한다.

<br>

### 변수를 재사용 하기보다 새로 만들자

> 변수를 재사용하면 변수 선언에 쏟는 노력을 좀 덜 순 있겠지만, 디버깅에 열 배 더 많은 시간을 쏟아야 한다.

- 변수를 추가하는 것은 좋은 습관이다.
- 변수를 추가한다고 해서 성능 이슈가 생기지 않는다. 
- 값이 다른 경우, 변수를 다르게 선언해 주면 코드 최적화에 도움이 될 수도 있다.

<br>

# 자료형

> 자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있는 언어를 ‘동적 타입(dynamically typed)’ 언어라고 부른다.

- `숫자형` – 정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용. 정수의 한계는 ±253

- `bigint` – 길이 제약 없이 정수를 나타낼 수 있다.

- `문자형` – 빈 문자열이나 글자들로 이뤄진 문자열을 나타낼 때 사용. 단일 문자를 나타내는 별도의 자료형은 없다.

  - 백틱으로 감싼 후 `${...}`안에 넣으면 변수나 표현식을 문자열 중간에 넣을 수 있다.

  ```javascript
  let name = "John";
  
  // 변수를 문자열 중간에 삽입
  alert( `Hello, ${name}!` ); // Hello, John!
  
  // 표현식을 문자열 중간에 삽입
  alert( `the result is ${1 + 2}` ); // the result is 3
  ```

  

- `불린형` – `true`, `false`를 나타낼 때 사용.

- `null` – `null` 값만을 위한 독립 자료형. `null`은 알 수 없는 값을 나타낸다.

- `undefined` – `undefined` 값만을 위한 독립 자료형. `undefined`는 할당되지 않은 값을 나타낸다.

- `객체형` – 복잡한 데이터 구조를 표현할 때 사용.

- `심볼형` – 객체의 고유 식별자를 만들 때 사용.

<br>

#### `typeof` 연산자는 피연산자의 자료형을 알려준다.

- `typeof x` 또는 `typeof(x)` 형태로 사용.
- 피연산자의 자료형을 문자열 형태로 반환.
- `null`의 typeof 연산은 `"object"`인데, 이는 언어상 오류. null은 객체가 아니다.

<br>

# alert, prompt, confirm을 이용한 상호작용

> 브라우저 환경에서 사용되는 최소한의 사용자 인터페이스 기능들

## alert

> 이 함수가 실행되면 사용자가 ‘확인(OK)’ 버튼을 누를 때까지 메시지를 보여주는 창이 계속 떠있게 된다.

```javascript
alert("Hello");
```

- 메시지가 있는 작은 창은 **모달 창(modal window)** 이라고 부른다.
  - '모달’ : 페이지의 나머지 부분과 상호 작용이 불가능하다는 의미
  - 따라서 사용자는 확인 버튼을 누르기 전까지 모달 창 바깥에 있는 버튼을 누른다든가 하는 행동을 할 수 없다.

<br>

## prompt

> 사용자에게 텍스트를 입력하라는 메시지를 띄워줌과 동시에, 입력 필드를 함께 제공합니다. 확인을 누르면 `prompt` 함수는 사용자가 입력한 문자열을 반환하고, 취소 또는 Esc를 누르면 `null`을 반환합니다.

```javascript
result = prompt(title, [default]);
```

- `title`

  사용자에게 보여줄 문자열

- `default`

  입력 필드의 초깃값(선택값)

```javascript
let age = prompt('나이를 입력해주세요.', 100);

alert(`당신의 나이는 ${age}살 입니다.`); 
// 당신의 나이는 100살입니다.
```

<br>

#### Internet Explorer(IE)에서는 항상 '기본값’을 넣어야 한다.

프롬프트 함수의 두 번째 매개변수는 선택사항이지만, 이 매개변수가 없는 경우 IE는 `"undefined"`를 입력 필드에 명시한다.

```javascript
let test = prompt("Test", ''); // <-- IE 사용자를 위한 매개변수 처리
```

<br>

## 컨펌 대화상자

> `confirm` 함수는 매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여준다.

사용자가 확인 버튼을 누르면 `true`, 그 외의 경우는 `false`를 반환한다.

```javascript
result = confirm(question);
```

```javascript
let isBoss = confirm("당신이 주인인가요?");

alert( isBoss ); // 확인 버튼을 눌렀다면 true가 출력된다.
```

<br>

# 형 변환

## 문자형으로 변환

- `String(value)` 문자열로 변환 가능.

<br>

## 숫자형으로 변환

> 숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.

```javascript
alert( "6" / "2" ); 
// 3, 문자열이 숫자형으로 자동변환된 후 연산이 수행됨.
```

- `Number(value)` 숫자형으로 변환 가능.

| 전달받은 값      | 형 변환 후                                                   |
| ---------------- | ------------------------------------------------------------ |
| `undefined`      | `NaN`                                                        |
| `null`           | `0`                                                          |
| `true and false` | `1` 과 `0`                                                   |
| `string`         | 문자열의 처음과 끝 공백이 제거됩니다. 공백 제거 후 남아있는 문자열이 없다면 `0`, 그렇지 않다면 문자열에서 숫자를 읽습니다. 변환에 실패하면 `NaN`이 됩니다. |

<br>

## 불린형으로 변환

- `Boolean(value)` 불리언으로 변환 가능.
- 숫자 `0`, 빈 문자열, `null`, `undefined`, `NaN`과 같이 직관적으로도 **비어있다고** 느껴지는 값들은 `false`.
- 그 외의 값은 `true`로 변환.

### 주의

> 문자열 `"0"`은  `true`이다. 비어 있지 않은 문자열은 언제나 `true`

```javascript
alert( Boolean("0") ); 
// true
alert( Boolean(" ") ); 
// 공백이 있는 문자열도 비어있지 않은 문자열이기 때문에 true로 변환.
```

<br>

# 기본 연산자와 수학

## 수학 연산자

- 덧셈 연산자 `+`,
- 뺄셈 연산자 `-`,
- 곱셈 연산자 `*`,
- 나눗셈 연산자 `/`,
- 나머지 연산자 `%`,
- 거듭제곱 연산자 `**`

<br>

### `+`는 문자열 연결도 가능하다

```js
let s = "my" + "string";
alert(s); // mystring

alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

- 하나가 문자열이면 다른 하나도 문자열로 변환된다

```js
alert(2 + 2 + '1' ); // '221'이 아니라 '41'이 출력
```

- 연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문

> 다른 산술 연산자는 오직 숫자형의 피연산자만 다루고, 피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾼다.

```js
alert( 6 - '2' ); // 4, '2'를 숫자로 바꾼 후 연산이 진행
alert( '6' / '2' ); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행
```

<br>

### 단항 연산자`+`는 숫자형으로 변환 가능하다.

> 피연산자가 숫자형이 아닐 때, 숫자형으로 변환한다. 하지만 숫자에 붙이면 아무런 동작을 하지 않는다.

```js
// 숫자형이 아닌 피연산자는 숫자형으로 변화한다.
alert( +true ); // 1
alert( +"" );   // 0
```

- 이는  `Number(...)`와 동일하지만 더 짧게 작성 할 수 있다.

```js
let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화한다.
alert( +apples + +oranges ); // 5
```

> 이항 연산자보다 단항 연산자가 더 우선순위가 높다. (지수, 곱셈보다 더 높다.)

<br>

## 할당 연산자

### 할당 연산자 체이닝

```js
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

- 가독성이 좋진 않다.

  ```js
  c = 2 + 2;
  b = c;
  a = c;
  ```

  - 이렇게 쓰는게 더 좋다.

### 복합 할당 연산자

```js
let n = 2;
n += 5; // n은 7이 됩니다(n = n + 5와 동일).
n *= 2; // n은 14가 됩니다(n = n * 2와 동일).

alert( n ); // 14
```

-  `/=`, `-=` 등도 가능하다.
- 할당 연산자와 우선순위가 동일하다. (거의 마지막이다.)

<br>

## 증가·감소 연산자

> 숫자를 하나씩 늘리거나 줄일 수 있다. 
>
> 코드를 더 짧게 작성할 수 있다.

**증가·감소 연산자는 `변수`에만 쓸 수 있다. `5++`와 같이 값에 사용하려고 하면 에러가 발생한다.**

- **증가(increment) 연산자** `++` : 변수를 1 증가

  ```js
  let counter = 2;
  counter++;
  // counter = counter + 1과 동일하게 동작. 하지만 식은 더 짧다.
  alert( counter ); // 3
  ```

- **감소(decrement) 연산자** `--` : 변수를 1 감소

  ```js
  let counter = 2;
  counter--;      // counter = counter - 1과 동일하게 동작. 하지만 식은 더 짧다.
  alert( counter ); // 1
  ```

<br>

- `counter++` : 후위형(postfix form)

  ```js
  let counter = 1;
  let a = counter++;
  
  alert(a); // 1
  ```

  - 증가 전의 **기존 값**을 반환

- `++counter` : 전위형(prefix form)

  ```js
  let counter = 1;
  let a = ++counter; // (*)
  
  alert(a); // 2
  ```

  - 증가 후의 **새로운 값**을 반환

- 반환 값을 사용하지 않는다면 차이가 없다.

  ```js
  let counter = 0;
  counter++;
  ++counter;
  alert( counter ); // 2, 위 두 라인은 동일한 연산을 수행
  ```

> 증가·감소 연산자의 우선순위는 다른 대부분의 산술 연산자보다 높다.

<br>

## 비트 연산자

> 비트 연산자(bitwise operator)는 인수를 32비트 정수로 변환하여 이진 연산을 수행
>
> 웹 개발 시 거의 사용하지 않는다.

- 비트 AND ( `&` )
- 비트 OR ( `|` )
- 비트 XOR ( `^` )
- 비트 NOT ( `~` )
- 왼쪽 시프트(LEFT SHIFT) ( `<<` )
- 오른쪽 시프트(RIGHT SHIFT) ( `>>` )
- 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( `>>>` )

<br>

## 쉼표 연산자

> 코드를 짧게 쓰려는 의도로 가끔 사용된다.

- 쉼표 연산자 `,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 한다.
- 이때 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환된다.

```js
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (3 + 4의 결과)
```

- 첫 번째 표현식 `1 + 2`은 평가가 되지만 그 결과는 버리고  `3 + 4`만 평가되어 `a`에 할당됨

```js
// 한 줄에서 세 개의 연산이 수행됨
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

- 여러 자바스크립트 프레임워크에서 볼 수 있다.

#### 쉼표의 우선순위는 매우 낮다.

> 할당 연산자 `=`보다 더 낮다.

```js
a = 1 + 2, 3 + 4
```

- `+`가 수행되어  `a = 3, 7`이 된다.
-  `a = 3`이 되고 `7`은 버려진다.